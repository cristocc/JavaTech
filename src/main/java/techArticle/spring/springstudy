一。逐行解读Spring（一） - 面试官：我看你写精通spring？讲一下xml配置解析的流程吧！
    https://juejin.cn/post/6845166890856218632

    1. beanDefinition注册流程
    我们知道，spring容器启动的逻辑在refresh()方法里面。所以，话不多说，直接点进refresh()逻辑，具体位置是 org.springframework.context.support.AbstractApplicationContext#refresh
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            prepareRefresh();
            // 本篇博文主要讲这个逻辑
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
            prepareBeanFactory(beanFactory);
            ...
    }

    本篇博文主要讲xml解析的逻辑，暂时我们只关注 obtainFreshBeanFactory()
    protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
        refreshBeanFactory();
        return getBeanFactory();
    }

    继续往下跟refreshBeanFactory()，实际上方法位置在org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory
    @Override
    protected final void refreshBeanFactory() throws BeansException {
        if (hasBeanFactory()) {
            destroyBeans();
            closeBeanFactory();
        }
        try {
            // 创建一个beanFactory
            DefaultListableBeanFactory beanFactory = createBeanFactory();
            beanFactory.setSerializationId(getId());
            customizeBeanFactory(beanFactory);
            // 加载所有的BeanDefinitions，实际解析xml的位置
            loadBeanDefinitions(beanFactory);
            synchronized (this.beanFactoryMonitor) {
                this.beanFactory = beanFactory;
            }
        }
        catch (IOException ex) {
            throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
        }
    }

    继续往下 org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)
    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
        // 这里使用了委托模式，把BeanDefinition的解析委托给了 BeanDefinitionReader
        // 由于我们当前是解析xml，所以是委托给Xml...Reader。合理想象，注解方式将会委托给Anno...Reader
        // 需要注意的是，我们把beanFactory引用传递给了Reader，之后会用到
        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
        // ... 为BeanDefinitionReader设置了一些不重要的属性，略过。
        // 加载BeanDefinition
        loadBeanDefinitions(beanDefinitionReader);
    }
    // XmlBeanDefinitionReader对应构造器，注意 beanFactory 是作为 BeanDefinitionRegistry 传入的
    public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) {
        super(registry);
    }

    protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
        Resource[] configResources = getConfigResources();
        if (configResources != null) {
            // 可以看到，是委托给Reader来加载BeanDefinition的
            reader.loadBeanDefinitions(configResources);
        }
        // 配置文件位置实际上就是我们 new ClassPathXmlApplicationContext("xxx") 时传入的
        String[] configLocations = getConfigLocations();
        if (configLocations != null) {
            // 可以看到，是委托给Reader来加载BeanDefinition的
            reader.loadBeanDefinitions(configLocations);
        }
    }

    经过一系列解析、包装、加载逻辑之后... org.springframework.beans.factory.xml.XmlBeanDefinitionReader#doLoadBeanDefinitions
    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
        throws BeanDefinitionStoreException {

        try {
            // 配置文件的输入流被加载成了Document --> XML解析知识，详细可搜素 SAX解析
            Document doc = doLoadDocument(inputSource, resource);
            // 解析并注册BeanDefinitions
            int count = registerBeanDefinitions(doc, resource);
            if (logger.isDebugEnabled()) {
                logger.debug("Loaded " + count + " bean definitions from " + resource);
            }
            return count;
        }
        // 异常处理，省略...
    }

    public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
        // 又来了，熟悉的委托模式，Document的解析被委托给了BeanDefinitionDocumentReader
        BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
        int countBefore = getRegistry().getBeanDefinitionCount();
        // 委托documentReader解析注册BeanDefinition，注意这里传入了一个 XmlReaderContext
        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
        return getRegistry().getBeanDefinitionCount() - countBefore;
    }
    // 可以看到XmlReaderContext的构造器传入了当前类-XmlBeanDefinitionReader
    // 而当前类持有BeanDefinitionRegistry，所以XmlReaderContext中持有了一个BeanDefinitionRegistry
    public XmlReaderContext createReaderContext(Resource resource) {
        return new XmlReaderContext(resource, this.problemReporter, this.eventListener,
                                    this.sourceExtractor, this, getNamespaceHandlerResolver());
    }

    细看DocumentReader解析过程 org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions
    protected void doRegisterBeanDefinitions(Element root) {
        // 代理的逻辑，我们暂时不看
        BeanDefinitionParserDelegate parent = this.delegate;
        this.delegate = createDelegate(getReaderContext(), root, parent);
        if (this.delegate.isDefaultNamespace(root)) {
            // ...
        }
        // 解析xml之前的钩子，暂时是空实现
        preProcessXml(root);
        // 解析逻辑
        parseBeanDefinitions(root, this.delegate);
        // 解析xml之前的钩子，暂时是空实现
        postProcessXml(root);
        this.delegate = parent;
    }

    protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
        // 判断是否是默认的命名空间
        if (delegate.isDefaultNamespace(root)) {
            NodeList nl = root.getChildNodes();
            for (int i = 0; i < nl.getLength(); i++) {
                Node node = nl.item(i);
                if (node instanceof Element) {
                    Element ele = (Element) node;
                    if (delegate.isDefaultNamespace(ele)) {
                        // 解析默认标签
                        parseDefaultElement(ele, delegate);
                    }
                    else {
                        // 可以看到代理主要进行自定义标签的解析 - CustomElement
                        delegate.parseCustomElement(ele);
                    }
                }
            }
        }
        else {
            // 可以看到代理主要进行自定义标签的解析 - CustomElement
            delegate.parseCustomElement(root);
        }
    }

    这里解释一下 自定义标签、自定义命名空间、默认标签、默认命名空间的含义
    <!-- 标签前面有 xxx:即是spring的自定义标签，我们也可以自己定义一个xiaozize:的标签-之后会讲到 -->
    <context:component-scan base-package="com.xiaoxizi.spring"/>
    <!-- 该标签对应的命名空间在xml文件头部beans标签中声明 -->
    <beans xmlns:context="http://www.springframework.org/schema/context" ... />

    <!-- 默认标签没有 xx: 前缀 -->
    <bean class="com.xiaoxizi.spring.service.AccountServiceImpl"   id="accountService" scope="singleton" primary="true"/>
    <!-- 对应的命名空间也在xml文件头部beans标签中声明 -->
    <beans xmlns="http://www.springframework.org/schema/beans" ... />

    我们先看默认标签的解析过程
    private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
        // 解析import标签，其实就是一个递归解析import导入的xml的过程
        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
            importBeanDefinitionResource(ele);
        }
        // 解析alias标签，一般很少用这个功能，我们不看这个逻辑
        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
            processAliasRegistration(ele);
        }
        // 解析bean标签，重头戏
        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
            processBeanDefinition(ele, delegate);
        }
        // 解析beans标签， 其实就是递归走了一次解析流程
        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
            // 这个方法眼熟吧？实际上我们就是从这个方法跟下来的
            doRegisterBeanDefinitions(ele);
        }
    }

    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
        // 具体的解析过程，将会把bean标签解析并封装到BeanDefinition中
        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
        if (bdHolder != null) {
            // 对bean标签解析出来的BeanDefinition进行装饰，用的很少
            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
            try {
                // Register the final decorated instance.
                // 注册BeanDefinition
                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
            }
            ...
        }
    }

2. bean标签解析
再正真解析bean标签前，我们先看一下spring的bean标签都有哪些属性和默认子标签
<bean
      class="com.xiaoxizi.spring.service.AccountServiceImpl"
      id="accountService"
      name="aaa"
      scope="singleton"
      abstract="false"
      parent="parent"
      autowire="byType"
      autowire-candidate="true"
      primary="true"
      depends-on="depends"
      init-method="init"
      destroy-method="destroy"
      factory-bean="factoryBean"
      factory-method="factoryMethod"
      lazy-init="false"
      >
    <description>一些描述</description>
    <constructor-arg ref="bean" value="固定值" type="参数类型" name="参数名称" index="索引"/>
    <property name="key1" value="固定值" ref="beanRef"/>
    <meta key="key1" value="固定值"/>
    <qualifier type="bean类型" value="限定的bean的名称"/>
    <lookup-method name="方法名" bean="bean名称"/>
    <replaced-method name="方法名" replacer="bean名称">
        <arg-type>参数类型，用于缺人唯一的方法</arg-type>
    </replaced-method>
</bean>

逐一说一下bean标签中属性作用：
属性                            作用
class                           指明bean所属的类
id                              bean在ioc容器中的唯一标识，如果不填将取别名中的第一个
name                            bean的别名
scope                           bean的scope，一般日常开发都是使用默认的singleton单例，还有prototype多例。事实上web环境还有request和session。而且我们也可以自定义scope（之后会讲到的）
abstract                        是否是抽象的，抽象的bean不会被实例化，只能被继承，用的很少
parent                          指定父bean，可以结合abstract一起使用，当然parent指向的bean并不一定要是抽象的
autowire                        被自动装配的模式，有byType，byName等可选
autowire-candidate              是否能被其他bean自动装配，false的话该bean将不能被其他bean注入，读者可以自行尝试一下
primary                         如果自动装配时匹配到多个bean，标记为primary的bean将被优先注入。
depends-on                      依赖，依赖的bean将会先被实例化
init-methodbean                 实例化之后将会调用的方法
destroy-methodbean              销毁时将会调用的方法，需要主要的是，只有单例的bean，IOC容器才持有其引用，IOC容器销毁 --> bean销毁时才会触发这个方法。
factory-bean                    工厂bean的名称，需要与factory-method结合使用，创建bean时将会调用factory-bean.factory-method()来获取当前类实例。
factory-method                  工厂bean方法，其实@Bean注解就是通过factory-bean、factory-method属性的功能实现的。
lazy-init                       是否是懒加载的

bean标签的默认子标签的作用：

子标签                              作用
description                         没啥作用，就是个描述而已
constructor-arg                     构造器注入时使用的标签，标明每个参数需要的值。用得少，因为可能会导致不能处理的循环依赖
property                            为bean中的属性注入值，常用
meta                                bean的元数据信息，业务开发中比较少用，之后跟源码过程中能看到使用的地方
qualifier                           与@Qualifier作用一致，当注入时出现多个匹配的bean时，将会注入qualifier限定的bean
lookup-method                       可以理解为覆盖/重写方法，把当前bean中的指定方法委托给指定的bean执行（例：把当前beanA.test() 方法委托给 beanB.test()，方法名必须一致），应用场景比较少。
replaced-method                     与lookup-method类似，只是该标签多了子标签用来准确定位方法，当待委托的方法有多个重名方法（重载）时可以使用。

继续往下看解析过程org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
    String id = ele.getAttribute(ID_ATTRIBUTE);
    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
	// 处理别名
    List<String> aliases = new ArrayList<>();
    if (StringUtils.hasLength(nameAttr)) {
        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
        aliases.addAll(Arrays.asList(nameArr));
    }
	// 默认id为beanName
    String beanName = id;
    if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
        // 如果不配置id，将会取第一个别名当做beanName
        beanName = aliases.remove(0);
        // ...
    }

    if (containingBean == null) {
        // 校验beanName、alias是否重复
        // 实际上有一个set用来存所以用过的name，避免重复 BeanDefinitionParserDelegate#usedNames
        checkNameUniqueness(beanName, aliases, ele);
    }
	// 要解析元素了，解析xml获取一个beanDefinition
    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
    if (beanDefinition != null) {
        // ... 跳过一些逻辑
        String[] aliasesArray = StringUtils.toStringArray(aliases);
        // 把beanDefinition封装成Holder
        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
    }
    return null;
}

解析方法parseBeanDefinitionElement中我们将把xml bean标签中的信息解析并封装到 一个BeanDefinition中，而之后（初始化流程），
我们将会根据BeanDefinition中的属性来创建bean实例。现在，先让我们看一下这个BeanDefinition的结构：
// 默认使用的是 GenericBeanDefinition
public class GenericBeanDefinition extends AbstractBeanDefinition {
    // 这个子类中只有一个parentName属性，明显对应bean标签的parent属性
    @Nullable
    private String parentName;
}
// 找父类，基本可以看到属性和bean标签的内容是一一对应的，不过meta子标签的信息还在父类里面
public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor
		implements BeanDefinition, Cloneable {
    @Nullable
	private volatile Object beanClass;

	@Nullable
	private String scope = SCOPE_DEFAULT;

	private boolean abstractFlag = false;

	@Nullable
	private Boolean lazyInit;

	private int autowireMode = AUTOWIRE_NO;

	private int dependencyCheck = DEPENDENCY_CHECK_NONE;

	@Nullable
	private String[] dependsOn;

	private boolean autowireCandidate = true;

	private boolean primary = false;
	// qualifier子标签信息
	private final Map<String, AutowireCandidateQualifier> qualifiers = new LinkedHashMap<>();

	@Nullable
	private Supplier<?> instanceSupplier;

	private boolean nonPublicAccessAllowed = true;

	private boolean lenientConstructorResolution = true;

	@Nullable
	private String factoryBeanName;

	@Nullable
	private String factoryMethodName;
	// constructor-arg 子标签的信息
	@Nullable
	private ConstructorArgumentValues constructorArgumentValues;
	// property子标签的信息
	@Nullable
	private MutablePropertyValues propertyValues;
	// lookup-method、replaced-method子标签的信息
	private MethodOverrides methodOverrides = new MethodOverrides();

	@Nullable
	private String initMethodName;

	@Nullable
	private String destroyMethodName;

    @Nullable
	private String description;
	// 加载这个beanDefinition的资源 -> 哪个xml
	@Nullable
	private Resource resource;
}
// BeanMetadataAttributeAccessor extends AttributeAccessorSupport
public abstract class AttributeAccessorSupport implements AttributeAccessor, Serializable {
	// 保存beanDefinition的元数据信息
	/** Map with String keys and Object values. */
	private final Map<String, Object> attributes = new LinkedHashMap<>();
}

好，我们继续往下解析bean标签
public AbstractBeanDefinition parseBeanDefinitionElement(
    Element ele, String beanName, @Nullable BeanDefinition containingBean) {
	// ...
    // 获取class属性
    String className = null;
    if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
    }
    // 获取parent属性
    String parent = null;
    if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
        parent = ele.getAttribute(PARENT_ATTRIBUTE);
    }

    try {
        // 创建了一个BeanDefinition，感兴趣的同学可以跟一下，实际上就是创建了一个
        // GenericBeanDefinition 并且把 parent set 进去了
        AbstractBeanDefinition bd = createBeanDefinition(className, parent);
		// 解析bean标签上的属性 scope， autowrite等
        // 感兴趣的同学可以跟一下，就是把值从xml中解析出来塞到beanDefinition而已
        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
        // description属性
        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

        // 解析meta子标签
        parseMetaElements(ele, bd);
        // 解析lockup-method子标签
        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
        // 解析replaced-method子标签
        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());
		// 解析constructor-arg子标签
        parseConstructorArgElements(ele, bd);
        // 解析property子标签
        parsePropertyElements(ele, bd);
        // 解析qualifier子标签
        parseQualifierElements(ele, bd);

        bd.setResource(this.readerContext.getResource());
        bd.setSource(extractSource(ele));

        return bd;
    }
	// ...
    return null;
}

// 因为解析的流程其实都差不多，这边简单挑几个有代表性的看一下
public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
    NodeList nl = ele.getChildNodes();
    for (int i = 0; i < nl.getLength(); i++) {
        Node node = nl.item(i);
        // 循环所有bean标签的子标签，找到mate标签
        if (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {
            Element metaElement = (Element) node;
            String key = metaElement.getAttribute(KEY_ATTRIBUTE);
            String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
            // 封装成BeanMetadataAttribute
            BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
            attribute.setSource(extractSource(metaElement));
            // 记住我们的beanDefinition是继承BeanMetadataAttributeAccessor的
            // 所以这里其实也是放到beanDefinition中了
            attributeAccessor.addMetadataAttribute(attribute);
        }
    }
}

public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {
    NodeList nl = beanEle.getChildNodes();
    for (int i = 0; i < nl.getLength(); i++) {
        Node node = nl.item(i);
        // 循环所有bean标签的子标签，找到lockup-method标签
        if (isCandidateElement(node) && nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {
            Element ele = (Element) node;
            String methodName = ele.getAttribute(NAME_ATTRIBUTE);
            String beanRef = ele.getAttribute(BEAN_ELEMENT);
            // 封装成LookupOverride
            LookupOverride override = new LookupOverride(methodName, beanRef);
            override.setSource(extractSource(ele));
            overrides.addOverride(override);
        }
    }
}
// 我们这里看一下MethodOverrides的结构
// 首先MethodOverrides是在beanDefinition创建的时候就初始化的
private MethodOverrides methodOverrides = new MethodOverrides();
public class MethodOverrides {
	// 其实就是一个MethodOverride列表
	private final Set<MethodOverride> overrides = new CopyOnWriteArraySet<>();
	// ...
}
// 继续看看MethodOverride
public abstract class MethodOverride implements BeanMetadataElement {
	// 被代理/重写的方法名
	private final String methodName;
	// 是否是重载的方法 - 重载的方法处理起来要复杂点
	private boolean overloaded = true;
	// ...
}
// MethodOverride只有两个子类，LookupOverride 和 ReplaceOverride，看名字大家都知道对应哪个标签了
public class LookupOverride extends MethodOverride {
    // 提供重写逻辑的bean的名称
	private final String beanName;
    // 可以看到，这个属性我们在解析xml的时候没有用到。
    // 这个应该是用来支持注解@Lockup的,因为这个功能用的很少，我也没去深究，不过字段的含义还是很好理解的
	private Method method;
}
public class ReplaceOverride extends MethodOverride {
	// 提供重写逻辑的bean的名称
	private final String methodReplacerBeanName;
	// 之前有说过replaced-method是用于目标方法有重载的情况，这个参数类型列表就是用来区分重载的方法的
    // 也是replaced-method标签的子标签arg-type中定义的
	private List<String> typeIdentifiers = new LinkedList<>();
}

那么致此，我们的一个默认的bean标签就解析完毕了，并且把所有的信息封装到了一个BeanDefinition实例中，然后这个beanDefinition将会注册到我们的IOC容器中去，
为下一步生成实例做准备。org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    // 具体的解析过程，将会把bean标签解析并封装到BeanDefinition中
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        // 对bean标签解析出来的BeanDefinition进行装饰，用的很少，但此处的是个spi很重要
        // 这里下一期再讲
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            // Register the final decorated instance.
            // 注册BeanDefinition
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        ...
    }
}

我们主要看一下注册beanDefinition的过程
public static void registerBeanDefinition(
    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
    throws BeanDefinitionStoreException {
    String beanName = definitionHolder.getBeanName();
    // 注册bean
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            // 注册别名
            registry.registerAlias(beanName, alias);
        }
    }
}

public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
    throws BeanDefinitionStoreException {
	// ... 这里去除掉了大部分的分支判断和异常处理逻辑，有兴趣的同学可以自行看一下
    // registerBeanDefinition的主要逻辑其实是以下两段
    // 将当前beanDefinition放入两个容器
    this.beanDefinitionMap.put(beanName, beanDefinition);
    this.beanDefinitionNames.add(beanName);
    // 这里是把当前bean从 manualSingletonNames 中删除，简单看了下逻辑
    // 对于通过 DefaultListableBeanFactory#registerSingleton(String beanName, Object singletonObject)
    // 直接注册到IOC容器中的单例bean，因为没有对应的beanDefinition，name相应的beanName会被记录到这个set
    // 而如果我们解析xml中获取到了相应的beanDefinition，就会将其从set中移除
    // 这个逻辑可以不看，不是主流程
    removeManualSingletonName(beanName);
}

四、总结
spring xml bean标签的解析就完整了，其实简单来讲，就是通过一系列手段，拿到xml bean标签中配置的各种属性，封装成一个BeanDefinition对象，
然后把这个对象存到我们IOC容器的 beanDefinitionMap、beanDefinitionNames中。这两个容器在之后的bean实例创建的过程中将会用到。



逐行解读Spring（二） - 什么，自定义标签没听说过？回去等通知吧！

1. 自定义标签的定义
这个问题其实上一篇有讲过，这边再复述一遍，在spring的xml配置文件中，我们可以把所有的标签分为两类：自定义标签和默认标签，区别如下
<!-- 标签前面有 xxx:即是spring的自定义标签，我们也可以自己定义一个xiaozize:的标签-之后会讲到 -->
<context:component-scan base-package="com.xiaoxizi.spring"/>
<!-- 该标签对应的命名空间在xml文件头部beans标签中声明 -->
<beans xmlns:context="http://www.springframework.org/schema/context" ... />

<!-- 默认标签没有 xx: 前缀 -->
<bean class="com.xiaoxizi.spring.service.AccountServiceImpl"
      id="accountService" scope="singleton" primary="true"/>
<!-- 对应的命名空间也在xml文件头部beans标签中声明 -->
<beans xmlns="http://www.springframework.org/schema/beans" ... />

2. 关于spring内置的自定义标签context:component-scan

二、源码解析
    1. 自定义标签解析过程
        由于上一篇对xml的源码跟过了，这期我们之间定位到相应代码org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseBeanDefinitions
        protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
            // 判断是否是默认的命名空间
            if (delegate.isDefaultNamespace(root)) {
                NodeList nl = root.getChildNodes();
                for (int i = 0; i < nl.getLength(); i++) {
                    Node node = nl.item(i);
                    if (node instanceof Element) {
                        Element ele = (Element) node;
                        if (delegate.isDefaultNamespace(ele)) {
                            // 解析默认标签
                            parseDefaultElement(ele, delegate);
                        }
                        else {
                            // 可以看到代理主要进行自定义标签的解析
                            delegate.parseCustomElement(ele);
                        }
                    }
                }
            }
            else {
                // 可以看到代理主要进行自定义标签的解析
                delegate.parseCustomElement(root);
            }
        }

        @Nullable
        public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {
            // 获取标签对于的namespaceUrl, 即配置文件头部beans标签里面那些xmlns:xxx=www.xxx.com
            String namespaceUri = getNamespaceURI(ele);
            if (namespaceUri == null) {
                return null;
            }
            // 获取自定义标签对应的NamespaceHandler，从这里我们可以看到，对于每一个namespaceUri应该都有唯一一个对应的NamespaceHandler
            NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
            if (handler == null) {
                error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", ele);
                return null;
            }
            // 把自定义标签委托给对应的NamespaceHandler解析
            return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));
        }

        我们先看一下NamespaceHandler这个自定义标签的解析接口的结构：
        public interface NamespaceHandler {
            // 初始化，我们可以合理猜测，这个方法将会在NamespaceHandler实例化之后，使用之前调用
            void init();
            // xml解析入口
            @Nullable
            BeanDefinition parse(Element element, ParserContext parserContext);
            // 装饰接口，其实用的比较少，上一篇有稍微带到过一下，默认bean标签解析完之后，可以有一个机会对解析出来的beanDefinition进行装饰，实际开发中很少使用
            // 有兴趣的同学可以自行看下源码，源码在 org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition
            @Nullable
            BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder definition, ParserContext parserContext);
        }
        public NamespaceHandler resolve(String namespaceUri) {
            // 获取到了一个handlerMapping，具体逻辑我们之后再看
            Map<String, Object> handlerMappings = getHandlerMappings();
            // 通过namespaceUri获取到一个对象
            Object handlerOrClassName = handlerMappings.get(namespaceUri);
            if (handlerOrClassName == null) {
                return null;
            }
            // 如果handlerOrClassName是一个NamespaceHandler对象，则直接返回 - 拿到对应的handler了
            else if (handlerOrClassName instanceof NamespaceHandler) {
                return (NamespaceHandler) handlerOrClassName;
            }
            else {
                // 如果handlerOrClassName不是NamespaceHandler对象，则是String对象
                String className = (String) handlerOrClassName;
                // 通过String获取到一个Class对象，那么这个String对象肯定是一个类的全限定名啦
                Class<?> handlerClass = ClassUtils.forName(className, this.classLoader);
                // handlerClass必须继承自NamespaceHandler，很好理解，毕竟是spring提供的拓展点，自然需要符合它定义的规则
                if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {
                    throw new FatalBeanException("...");
                }
                // 直接通过反射构造一个实例，点进去看会发现是调用的无参构造器，我们就不看了
                NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);
                // !!! 调用了init()方法，和我们之前的推测一致
                namespaceHandler.init();
                // !!! 把handler对象塞回了handlerMappings，所以我们下次再通过namespaceUri获取时，会直接拿到一个NamespaceHandler对象
                // 也即每个namespaceUri对应的NamespaceHandler对象是单例的，而init()方法也只会调用一次
                handlerMappings.put(namespaceUri, namespaceHandler);
                return namespaceHandler;
                // 去除掉了异常处理
            }
        }

        由上述源码其实我们已经得知了NamespaceHandler的一个初始化过程，但其实还有一个疑问，就是这个handlerMappings中最初的那些namespaceUri对应的handler的类名是哪来的呢？
        这个时候我们就需要去看一下getHandlerMappings()的过程啦

        private Map<String, Object> getHandlerMappings() {
            Map<String, Object> handlerMappings = this.handlerMappings;
            if (handlerMappings == null) {
                synchronized (this) {
                    handlerMappings = this.handlerMappings;
                    // 双重检查加锁，看来我们的handlerMappings之后加载一次
                    if (handlerMappings == null) {
                        // 可以看到这边是去加载了文件
                        // 文件加载的过程我们就不去跟了，跟主流程关系不大，我们主要看一下这个文件位置
                        // this.handlerMappingsLocation是哪里
                        Properties mappings =
                            PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);
                        handlerMappings = new ConcurrentHashMap<>(mappings.size());
                        // 然后把文件中的kev-value属性都合并到了一个map里
                        CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);
                        this.handlerMappings = handlerMappings;
                        // 干掉了异常处理代码
                    }
                }
            }
            return handlerMappings;
        }
        // 字段的定义， 需要说一下当前类是DefaultNamespaceHandlerResolver，喜欢自己探索的同学可以直接空降
        /** Resource location to search for. */
        private final String handlerMappingsLocation;
        // 可以看到这个值是Resolver的构造器中设值的
        public DefaultNamespaceHandlerResolver(@Nullable ClassLoader classLoader, String handlerMappingsLocation) {
            this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());
            this.handlerMappingsLocation = handlerMappingsLocation;
        }
        // 默认是取的DEFAULT_HANDLER_MAPPINGS_LOCATION这个常量
        public DefaultNamespaceHandlerResolver() {
            this(null, DEFAULT_HANDLER_MAPPINGS_LOCATION);
        }
        // 我们看一下这个常量的值
        public static final String DEFAULT_HANDLER_MAPPINGS_LOCATION = "META-INF/spring.handlers";
        如果对SPI比较熟悉的同学，应该已经知道这是个什么套路了，并且对META-INF这个目录也比较熟悉，
        那么现在，我们看一下这个META-INF/spring.handlers文件中到底写了一些什么东西，
        以context:component-scan标签为例，我们知道这个标签是spring-context包里面提供的，直接去找这个jar包的对应文件，看一下里面的内容：
        ## 我们可以很明显的看到一个key=value结构
        http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler
        http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler
        http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler
        http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler
        http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler

        我们在回忆一下自定义标签的定义：
        <!-- 标签前面有 xxx:即是spring的自定义标签，我们也可以自己定义一个xiaozize:的标签-之后会讲到 -->
        <context:component-scan base-package="com.xiaoxizi.spring"/>
        <!-- 该标签对应的命名空间在xml文件头部beans标签中声明 -->
        <beans xmlns:context="http://www.springframework.org/schema/context" ... />

        可以看到我们的META-INF/spring.handlers文件中key就是自定义标签的namespaceUri，value则是对应的NamespaceHandler的全限定名。
        那么简单总结一下，我们的自定义标签解析的流程就是：

        1.加载所有jar中META-INF/spring.handlers文件中的namespaceUri和NamespaceHandler的全限定名的映射关系到handlerMappings

        2.根据namespaceUri从handlerMappings获取对象
        如果从handlerMappings获取到的对象为空，直接返回
        如果获取到的是NamespaceHandler对象，直接使用
        如果获取到的对象是string类型，则实例化这个string对应的全限定名的NamespaceHandler对象，并调用init()方法，
        然后将 namespaceUri-NamespaceHandler对象关系放回handlerMappings

        3.将自定义标签委托给2获取到的NamespaceHandler对象解析-调用parse方法（如果2未获取到对应的NamespaceHandler对象，则此自定义标签无法解析，直接跳过）


    2. context:component-scan标签工作原理
        接下来我们来看一下 context:component-scan标签的工作原理，从spring-context包的META-INF/spring.handlers文件我们可以找到该标签对应的处理器：
        http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler
        直接找到这个类：
        public class ContextNamespaceHandler extends NamespaceHandlerSupport {
            @Override
            public void init() {
                // 删掉了一些我们不关注的标签的Parser的注入代码...
                // 我们可以看到这里注册了一个BeanDefinitionParser，而且这个注册方法的第一个参数明显是
                // `context:component-scan` 标签中删掉前缀的部分，我们先记下来
                registerBeanDefinitionParser("component-scan", new ComponentScanBeanDefinitionParser());
                // 删掉了一些我们不关注的标签的Parser的注入代码...
            }
        }
        可以看到ContextNamespaceHandler继承自NamespaceHandlerSupport，这是一个典型的模本方法设计模式。这里不做拓展，我们直接看一下NamespaceHandlerSupport：
        // 这里我们只保存了与解析器相关的代码，并且调整了一下源码顺序
        // 装饰相关的代码我去除掉了，并不是NamespaceHandlerSupport中没有，不过它的逻辑和解析基本是一致的
        // 如果同学们还记得哪里对beanDefinition进行了装饰，并且感兴趣的话，可以自行了解一下 (*￣︶￣)
        public abstract class NamespaceHandlerSupport implements NamespaceHandler {
            // 保存标签名-解析器对应关系的容器
        	private final Map<String, BeanDefinitionParser> parsers = new HashMap<>();
            // 保存标签名-装饰器对应关系的容器
        	private final Map<String, BeanDefinitionDecorator> decorators = new HashMap<>();
            // 保存属性名-装饰器对应关系的容器
        	private final Map<String, BeanDefinitionDecorator> attributeDecorators = new HashMap<>();
            // 可以看到我们init()方法中的register其实就只是把对应elementName-Parser放入map而已
        	protected final void registerBeanDefinitionParser(String elementName, BeanDefinitionParser parser) {
        		this.parsers.put(elementName, parser);
        	}
        	public BeanDefinition parse(Element element, ParserContext parserContext) {
                // 获取 Parser
        		BeanDefinitionParser parser = findParserForElement(element, parserContext);
                // 委托给 Parser解析
        		return (parser != null ? parser.parse(element, parserContext) : null);
        	}
        	private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {
                // 这里是获取了去掉标签中去掉前缀后的名称 context:component-scan --> component-scan
        		String localName = parserContext.getDelegate().getLocalName(element);
                // 从map中获取到对应的Parser
        		return this.parsers.get(localName);
        	}
        }

        到此为止其实还是蛮简单的嘛，我们又把标签委托给了对应的Parser来处理，
        那么我们现在来看一下component-scan对应的ComponentScanBeanDefinitionParser的逻辑，我们先看parse方法，也是我们的入口方法：
        public BeanDefinition parse(Element element, ParserContext parserContext) {
            // 获取标签上配置并处理的base-package属性
            String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);
            // 处理占位符
            basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
            // 最终获取到的是一个数组 - 因为我们配置的时候是可以配置多个的
            String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,
                                                        ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);

            // 获取一个扫描器 - 这个东西很重要，我们以后还会看到
            ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);
            // 嗯，扫描器进行扫描，看来就是这个方法会扫描那些注解了
            Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);
            // 注册一些组件
            registerComponents(parserContext.getReaderContext(), beanDefinitions, element);
            return null;
        }

        我们先看一下扫描器是怎么创建出来的：
        // 把一些异常处理都干掉了
        protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {
            // 解析一下是否用默认的过滤器 --> 这里解释一下，其实这个过滤器就是指我们那些注解@Service等。
            // 其实这里就是定义那些注解是我们扫描到了之后会把它纳入IOC管理的，具体代码之后解析的时候会看到
            boolean useDefaultFilters = true;
            if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) {
                useDefaultFilters = Boolean.parseBoolean(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));
            }
        	// 直接创建一个扫描器
            ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters);
            // 从parserContext获取到的默认的beanDefinition的配置，即之后解析的beanDefinition的缺省配置
            scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());
            // 从parserContext获取到的默认的自动装配的模式，byType、byName那些
            scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());
        	// 扫描的资源路径，一般我们也不配置
            if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) {
                scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));
            }
            // 没什么用的...一般也不会去自定义，即使用注解时，生成bean的name的策略也可以自定义
            parseBeanNameGenerator(element, scanner);
            // 基本也不用，scope相关的，大概意思就是这个bean会存在于哪些scope，一般不用
            parseScope(element, scanner);
            // 解析类型过滤器-这个算相对重要，其实就是我们可以自定义需要扫描哪些注解
            parseTypeFilters(element, scanner, parserContext);

            return scanner;
        }

        我们先看一下如果useDefaultFilters=true会注册哪些过滤器，createScanner中其实就是直接调用了构造器，那我们直接看一下构造器逻辑：
        public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry,
                                              boolean useDefaultFilters,
                                              Environment environment,
                                              @Nullable ResourceLoader resourceLoader) {
            Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
            this.registry = registry;
            if (useDefaultFilters) {
                // 注册默认的过滤器
                registerDefaultFilters();
            }
            setEnvironment(environment);
            setResourceLoader(resourceLoader);
        }
        protected void registerDefaultFilters() {
            // includeFilters添加了一个AnnotationTypeFilter，过滤器构造器传入了Component的Class对象
            this.includeFilters.add(new AnnotationTypeFilter(Component.class));
            // 省略了两个JSR规范注解的注册代码，我们一般用不到，@javax.annotation.ManagedBean和@javax.inject.Named
        }

        我们解析来看一下类型过滤器标签的解析：
        protected void parseTypeFilters(Element element, ClassPathBeanDefinitionScanner scanner, ParserContext parserContext) {
            // ...
            NodeList nodeList = element.getChildNodes();
            for (int i = 0; i < nodeList.getLength(); i++) {
                Node node = nodeList.item(i);
                // 找到每一个子节点
                if (node.getNodeType() == Node.ELEMENT_NODE) {
                    String localName = parserContext.getDelegate().getLocalName(node);
                    if (INCLUDE_FILTER_ELEMENT.equals(localName)) {
                        // 如果是<include-filter/>标签则创建一个Filter并加入includeFilters
                        TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);
                        scanner.addIncludeFilter(typeFilter);
                    }
                    else if (EXCLUDE_FILTER_ELEMENT.equals(localName)) {
                        // 如果是<exclude-filter/>标签则创建一个Filter并加入includeFilters
                        TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);
                        scanner.addExcludeFilter(typeFilter);
                    }
                }
            }
        }

        那么我们看一下createTypeFilter究竟做了一些什么：
        // 逻辑还是比较直观的
        protected TypeFilter createTypeFilter(Element element, @Nullable ClassLoader classLoader,
                                              ParserContext parserContext) {
            String filterType = element.getAttribute(FILTER_TYPE_ATTRIBUTE);
            String expression = element.getAttribute(FILTER_EXPRESSION_ATTRIBUTE);
            expression = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(expression);
            if ("annotation".equals(filterType)) {
                // 如果我们想扫描自定义的注解，那可以使用这个annotation类型，expression填注解全限定名就好了
                return new AnnotationTypeFilter((Class<Annotation>) ClassUtils.forName(expression, classLoader));
            }
            else if ("assignable".equals(filterType)) {
                // 扫描配置的类及其子类，expression填类的全限定名就好了，这个也偶尔用到，主要用来指定扫描一些二方库的bean
                return new AssignableTypeFilter(ClassUtils.forName(expression, classLoader));
            }
            else if ("aspectj".equals(filterType)) {
                // 扫描切面表达式所匹配的类
                return new AspectJTypeFilter(expression, classLoader);
            }
            else if ("regex".equals(filterType)) {
                // 扫描正则表达式所匹配的类
                return new RegexPatternTypeFilter(Pattern.compile(expression));
            }
            else if ("custom".equals(filterType)) {
                // 自定义的过滤器，对应的类需要实现TypeFilter接口
                Class<?> filterClass = ClassUtils.forName(expression, classLoader);
                if (!TypeFilter.class.isAssignableFrom(filterClass)) {
                    throw new IllegalArgumentException(
                        "Class is not assignable to [" + TypeFilter.class.getName() + "]: " + expression);
                }
                return (TypeFilter) BeanUtils.instantiateClass(filterClass);
            }
            else {
                throw new IllegalArgumentException("Unsupported filter type: " + filterType);
            }
        }

        好了，context:component-scan标签的属性解析就告一段落了，我们主要记住base-package和Filter相关的就好了，
        其余的其实也用不太到，毕竟这个扫描的功能主要只需要确定需要扫描哪些包以及需要关注哪些类就好了。
        那么我们接下来再往回看一下，扫描器的扫描逻辑是怎么样的，同学们可以空降ComponentScanBeanDefinitionParser#parse，
        然后我们来看一下获取到scanner之后，scanner.doScan(basePackages)的逻辑：

        protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
            for (String basePackage : basePackages) {
                // 找到所以扫描到的beanDefinition
                Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
                for (BeanDefinition candidate : candidates) {
                    // 获取beanName，要知道，我们使用注解的时候，其实是没有一个像xml标签属性那样的东西来获取name的
                    // 这里通过beanNameGenerator来获取了beanName，默认就是通过注解内的对应属性或者类名。感兴趣的同学可以看下 AnnotationBeanNameGenerator
                    String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
                    // 删掉了一下不重要的属性的赋值
                    if (candidate instanceof AnnotatedBeanDefinition) {
                    // 里是处理类上的一些公共注解的地方，比如@Primary，@Lazy等
                        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
                    }
                    // 这个判断的大概意思就是，看一下我们扫描出来的beanDifinition是不是第一次注册
                    // 如果不是第一次注册就不会再注册了，是通过beanName来从IOC容器中找有没有一样的
                    if (checkCandidate(beanName, candidate)) {
        				// ...
                        // 注册bean，这个逻辑我们第一篇看过了，就不在看了，实际上就是把beanDefinition放入
                        // beanDefinitionMap和beanDefinitionNames这两个容器里面
                        registerBeanDefinition(definitionHolder, this.registry);
                    }
                }
            }
            return beanDefinitions;
        }

        我们先看一下是怎么AnnotationConfigUtils.processCommonDefinitionAnnotations()中是怎么处理类上的注解的：
        static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
            AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
            if (lazy != null) {
                abd.setLazyInit(lazy.getBoolean("value"));
            }
            else if (abd.getMetadata() != metadata) {
                lazy = attributesFor(abd.getMetadata(), Lazy.class);
                if (lazy != null) {
                    abd.setLazyInit(lazy.getBoolean("value"));
                }
            }
            if (metadata.isAnnotated(Primary.class.getName())) {
                abd.setPrimary(true);
            }
            AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
            if (dependsOn != null) {
                abd.setDependsOn(dependsOn.getStringArray("value"));
            }

            AnnotationAttributes role = attributesFor(metadata, Role.class);
            if (role != null) {
                abd.setRole(role.getNumber("value").intValue());
            }
            AnnotationAttributes description = attributesFor(metadata, Description.class);
            if (description != null) {
                abd.setDescription(description.getString("value"));
            }
        }

        大聪明们肯定已经发现了，其实就是看一下类上面有没有对应的注解，然后把对应的属性塞入beanDefinition对象嘛。这岂不是可以说是跟XML解析获取beanDefinition时的流程一模一样的？
        是的，其实不管是基于注解还是基于xml，都是把一些描述bean的信息，收集汇总到相应的beanDefinition中而已。而beanDefinition的属性决定了这个bean会怎么实例化，需要注入哪些属性等等等等。
        收集信息来注解beanDefinition的途径可以有多种--甚至你自己写一个解析json格式文件的组件也不是不行，但是结果都是殊途同归的。
        从这也可以看出spring设计的强大，这种模块化的设计思想和对单一职责原则（比较直观的是各种委托模式，专业的事给专业的类做）
        和开闭原则（到我们现在讲到的地方：自定义标签的设计，在不触动原有核心逻辑的情况下，我们可以很简单的对spring做一些自定义的拓展）的实践。

        接下来我们具体看下扫描器是怎么扫描到那些被注解标记的类的（其实就是对之前注册的过滤器的应用），
        findCandidateComponents()中调用了scanCandidateComponents()，我们之间看scanCandidateComponents()：

        // 去除掉了异常处理和日志打印
        private Set<BeanDefinition> scanCandidateComponents(String basePackage) {
            Set<BeanDefinition> candidates = new LinkedHashSet<>();
            String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
                resolveBasePackage(basePackage) + '/' + this.resourcePattern;
            // 这一段逻辑极其复杂切对我们理解主流程没太大帮助，我们就不看了（主要是涉及到模糊匹配的文件寻找）
            // 大概就是把所有符合的类文件找出来了
            Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
            for (Resource resource : resources) {
                // 解析文件信息，加载到内存，这里看下去也贼复杂，都是一些字节码解析技术了
                // 我们只需要知道这样操作一番后，这个MetadataReader能拿到我们这个类的所有信息就好了
                MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
                // 这里就是我们过滤器发挥作用的地方了，符合条件的类才会生成beanDefinition
                if (isCandidateComponent(metadataReader)) {
                    ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                    sbd.setResource(resource);
                    sbd.setSource(resource);
                    // 这里主要判断一下，我们匹配到的类是不是一个符合条件的bean
                    // 比如说如果我们注解打在接口上，这里就不会把这个beanDefinition加入返回的容器了
                    if (isCandidateComponent(sbd)) {
                        candidates.add(sbd);
                    }
                }
            }
        	return candidates;
        }
        // 过滤器判断是否是我们关注的类，逻辑很直观
        protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
            // 先判断的excludeFilters
            for (TypeFilter tf : this.excludeFilters) {
                if (tf.match(metadataReader, getMetadataReaderFactory())) {
                    return false;
                }
            }
            // 再判断的includeFilters
            for (TypeFilter tf : this.includeFilters) {
                if (tf.match(metadataReader, getMetadataReaderFactory())) {
                    // 如果是我们关注的类，还需要处理类上面的@Conditional注解
                    // 这里不继续往下拓展了，我简单讲一下逻辑：
                    // 	1.找到类上面所有的@Conditional簇的注解
                    //  2.实例化所有对应的Conditional类，并排序
                    //  3.依次调用所有condition.matches()，所有条件全部满足才返回true
                    // 具体细节同学们感兴趣可以自己看下
                    return isConditionMatch(metadataReader);
                }
            }
            return false;
        }
        // 判断是否不是接口那些
        protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
            return (metadata.isIndependent() // 不是实例内部类 并且
                    && (metadata.isConcrete() // 不是接口或者抽象类 或者
                        ||
                                                 (metadata.isAbstract() && metadata.hasAnnotatedMethods(Lookup.class.getName()))));
            // 是抽象类但是有些方法被@Lookup注解标记，这个之前有稍微提过，xml标签里那个lookup-method标签跟这个是一个意思，相当于把这个方法委托/代理给另一个bean了，所以即使是抽象类也是可以变成一个bean的 -> spring动态代理生成一个子类
        }
    3. Filter匹配流程
        主要讲一下我们用的比较多的AnnotationTypeFilter，先看一下AnnotationTypeFilter的构造器：
        // 我们简单看一下AnnotationTypeFilter的构造器
        public AnnotationTypeFilter(Class<? extends Annotation> annotationType) {
            this(annotationType, true, false);
        }
        // 可以看到，我们扫描@Component注解时，是考虑源注解，且不考虑接口上的注解的
        public AnnotationTypeFilter(
            // 注解类型
            Class<? extends Annotation> annotationType,
            // 是否考虑源注解
            boolean considerMetaAnnotations,
            // 是否考虑接口
            boolean considerInterfaces) {
            // 第一个参数是是否考虑继承的注解
            super(annotationType.isAnnotationPresent(Inherited.class), considerInterfaces);
            this.annotationType = annotationType;
            this.considerMetaAnnotations = considerMetaAnnotations;
        }

        再看一下核心的match方法，这里也是一个模板方法模式：

        // 先看顶层类
        public abstract class AbstractTypeHierarchyTraversingFilter implements TypeFilter {
            @Override
            public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
                throws IOException {
        		// 直接看当前类是否匹配 - 模板方法，由子类实现，默认返回了false
                if (matchSelf(metadataReader)) {
                    return true;
                }
                // 提供一个通过className判断是否匹配的钩子
                ClassMetadata metadata = metadataReader.getClassMetadata();
                if (matchClassName(metadata.getClassName())) {
                    return true;
                }
                if (this.considerInherited) {
                    // 如果考虑继承的注解，则找到对应的父类
                    String superClassName = metadata.getSuperClassName();
                    if (superClassName != null) {
                        // 先看下子类有没有 单独判断父类是否匹配 的逻辑
                        Boolean superClassMatch = matchSuperClass(superClassName);
                        if (superClassMatch != null) {
                            // 有写这个逻辑则直接用这个返回结果了
                            if (superClassMatch.booleanValue()) {
                                return true;
                            }
                        }
                        else {
                            // 没有 单独判断父类是否匹配 的逻辑 则直接走当前这个匹配逻辑
                            if (match(metadata.getSuperClassName(), metadataReaderFactory)) {
                                return true;
                            }
                        }
                    }
                }
                if (this.considerInterfaces) {
                    // 如果考虑接口的注解，则找到对应的接口，因为接口是多个，所以要循环
                    // 逻辑和父类那里类似，不多讲了
                    for (String ifc : metadata.getInterfaceNames()) {
                        Boolean interfaceMatch = matchInterface(ifc);
                        if (interfaceMatch != null) {
                            if (interfaceMatch.booleanValue()) {
                                return true;
                            }
                        }
                        else {
                            if (match(ifc, metadataReaderFactory)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
        }
        再看一下AnnotationTypeFilter的几个核心方法：
        public class AnnotationTypeFilter extends AbstractTypeHierarchyTraversingFilter {
        	protected boolean matchSelf(MetadataReader metadataReader) {
        		AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();
                // 类上有目标注解
        		return metadata.hasAnnotation(this.annotationType.getName()) ||
                    // 如果可以从源注解拿，则找一下类上面有没有源注解是和目标注解一样的
        				(this.considerMetaAnnotations && metadata.hasMetaAnnotation(this.annotationType.getName()));
        	}
        	protected Boolean matchSuperClass(String superClassName) {
        		return hasAnnotation(superClassName);
        	}
        	protected Boolean matchInterface(String interfaceName) {
        		return hasAnnotation(interfaceName);
        	}

        	@Nullable
        	protected Boolean hasAnnotation(String typeName) {
        		if (Object.class.getName().equals(typeName)) {
        			return false;
        		}
                // 这个父类和接口的匹配逻辑居然只能匹配到jdk内置（java开头）的类
                // 看来默认的实现应该是用来支持JSR标准的那些注解的
        		else if (typeName.startsWith("java")) {
        			// ... 不关注
        		}
        		return null;
        	}
        }

        我们可以看到，我们默认的AnnotationTypeFilter是考虑源注解的，那么这个源注解到底是个什么东西呢？

        public @interface Controller {
        	@AliasFor(annotation = Component.class)
        	String value() default "";
        }
        public @interface Service {
        	@AliasFor(annotation = Component.class)
        	String value() default "";
        }
        public @interface Repository {
        	@AliasFor(annotation = Component.class)
        	String value() default "";
        }

        常见的就是这个东西啦@AliasFor(annotation = Component.class)，
        这也是为什么我们默认的includeFilters明明只注册了一个@Component类型的AnnotationTypeFilter，
        但是我们@Service等也能被扫描到的原因啦！我们构造的AnnotationTypeFilter是考虑源注解的！
    4. 注册公共组件
        看到这里，我们已经明白了context:component-scan标签是怎么扫描，
        怎么支持@Component注解的了，但是细心的同学们可能已经发现了，现在我们确实能扫描@Component注解了，
        但是我们bean中那些属性是怎么注入的呢？@Autowrite、@Resource这些注解是怎么支持的呢？以及@Configuration、@Bean又是如何支持的呢？
        这些功能其实是在相应的BeanPostProcessor中完成的，而这些BeanPostProcessor的注册，
        也是在我们context:component-scan标签的解析过程中注入的。如果同学们还有印象的话，
        应该还记得ComponentScanBeanDefinitionParser的parse方法中，我们再创建了扫描器并且进行扫描之后，还做了一些公共组件注册的工作：
        public BeanDefinition parse(Element element, ParserContext parserContext) {
            // ...
            // 获取一个扫描器 - 这个东西很重要，我们以后还会看到
            ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);
            // 嗯，扫描器进行扫描，看来就是这个方法会扫描那些注解了
            Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);
            // 注册一些组件
            registerComponents(parserContext.getReaderContext(), beanDefinitions, element);
            return null;
        }
        我们看一下registerComponents方法：

        protected void registerComponents(
            XmlReaderContext readerContext, Set<BeanDefinitionHolder> beanDefinitions, Element element) {
        	// ...
            // Register annotation config processors, if necessary.
            boolean annotationConfig = true;
            if (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) {
                annotationConfig = Boolean.parseBoolean(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE));
            }
            // 看下annotation-config配置，默认是为true的
            if (annotationConfig) {
                Set<BeanDefinitionHolder> processorDefinitions =
                    // 注册一些支撑注解功能的Processors
                    AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);
        		// ...
            }
        	// ...
        }
        那么到底注册了哪些Processor呢？

        public static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(
            BeanDefinitionRegistry registry, @Nullable Object source) {
        	// ...
            Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);

            // 这里注册了一个ConfigurationClassPostProcessor，顾名思义，这个应该是支撑@Configuration相关的注解的
            if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
                RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
                def.setSource(source);
                // 注册逻辑registerPostProcessor
                beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
            }
        	// 注册了一个AutowiredAnnotationBeanPostProcessor，用来处理@Autowire，@Value注解的
            if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
                RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
                def.setSource(source);
                beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
            }

            // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.
            // 这里是支撑JSR-250规范的@Resource、@PostConstruct、@PreDestroy注解的
            if (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
                RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
                def.setSource(source);
                beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
            }

            // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.
            // 这里是支持注解形式的jpa的BeanPostProcessor
            if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
                RootBeanDefinition def = new RootBeanDefinition();
                try {
                    def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
                                                        AnnotationConfigUtils.class.getClassLoader()));
                }
                catch (ClassNotFoundException ex) {
                    throw new IllegalStateException(
                        "Cannot load optional framework class: " + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
                }
                def.setSource(source);
                beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
            }
        	// 支撑spring-event相关注解的processor，对@EventListener的支撑
            if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
                RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
                def.setSource(source);
                beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
            }
        	// 支撑spring-event相关注解的processor，对@EventListener的支撑
            if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
                RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
                def.setSource(source);
                beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
            }
            return beanDefs;
        }

        到此，context:component-scan标签所做的所有事情都做完了。
        它主要就是创建了一个扫描器来扫描我们基本的需要注册的bean，
        之后注册了一些支撑相应注解功能的Processor，对于这些Processor，
        我这边不会去单独讲解每个Processor是什么时候被调用，怎么实现它的功能的，感兴趣的同学可以自行找到对应的类去看实现逻辑。
        而之后讲bean初始化逻辑和生命周期的时候，我会在特定的拓展点，讲到一些Processor的调用以及内部的逻辑，希望到时候同学们还能记起来这些Processor是在哪里注册的。

    三、实践
        都说实践出真知，我们跟着源码分析了这么一大波，但是事实是不是如我们分析的那样呢？为了证实一下，这边我简单使用一下spring预留的拓展点。
        1. 使用context:component-scan扫描自定义注解

        我们首先需要自定义一个注解：
        @Target({ElementType.TYPE})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface MyService {

        }
        然后配置一下context:component-scan标签：

        <context:component-scan base-package="com.xiaoxizi.spring">
            <context:include-filter type="annotation" expression="com.xiaoxizi.spring.annotation.MyService"/>
        </context:component-scan>

        为我们的业务类打上注解：
        @Data
        @MyService
        public class MyAnnoClass {
            public String username = "xiaoxizi";
        }
        运行：
        public void test1() {
            applicationContext = new ClassPathXmlApplicationContext("spring.xml");
            MyAnnoClass myAnnoClass = applicationContext.getBean(MyAnnoClass.class);
            System.out.println(myAnnoClass);
        }
        输出结果：MyAnnoClass(username=xiaoxizi)

        2. 自定义标签

        先创建一个具体标签的解析类，我们这边简单点，直接继承了spring内部的一个类：

        public class SimpleBeanDefinitionParse extends AbstractSingleBeanDefinitionParser {
            @Override
            protected String getBeanClassName(final Element element) {
                System.out.println("SimpleBeanDefinitionParse ... getBeanClassName()");
                return element.getAttribute("className");
            }
        }
        然后创建一个SimpleNamespaceHandler：
        public class SimpleNamespaceHandler extends NamespaceHandlerSupport {
            @Override
            public void init() {
                System.out.println("SimpleNamespaceHandler ... init()");
                this.registerBeanDefinitionParser("simpleBean", new SimpleBeanDefinitionParse());
            }
        }

        配置写入META-INF/spring.handlers文件：http\://www.xiaoxize.com/schema/simple=com.xiaoxizi.spring.tag.SimpleNamespaceHandler

        xml配置中使用：
        <xiaoxizi:simple className="com.xiaoxizi.spring.bean.MyAnnoClass"/>
        <!-- 该标签对应的命名空间在xml文件头部beans标签中声明 -->
        <beans xmlns:xiaoxizi="http://www.xiaoxize.com/schema/simple" ... />

        目标类：
        @Data
        // @MyService
        public class MyAnnoClass {
            public String username = "xiaoxizi";
        }
        运行：
        public void test1() {
            applicationContext = new ClassPathXmlApplicationContext("spring.xml");
            MyAnnoClass myAnnoClass = applicationContext.getBean(MyAnnoClass.class);
            System.out.println(myAnnoClass);
        }
        输出结果-各种报错，哈哈哈：
        Caused by: org.xml.sax.SAXParseException; lineNumber: 21; columnNumber: 91; cvc-complex-type.2.4.c: 通配符的匹配很全面,
        但无法找到元素 'xiaoxizi:simple' 的声明。
        复制代码
        emmmm，翻车车啦~这里还是卡了一会的，主要是对xml规范的不熟悉导致的，原来我们在声明命名空间的时候，还要声明并定义对应的XSD文件，
        （这里我自己写了一个xsd文件，并通过idea的配置引入了工作空间）像这样：
        <xiaoxizi:simple className="com.xiaoxizi.spring.bean.MyAnnoClass"/>
        <!-- 该标签对应的命名空间在xml文件头部beans标签中声明 -->
        <beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:xiaoxizi="http://www.xiaoxize.com/schema/simple"
               xsi:schemaLocation="
                                   http://www.xiaoxize.com/schema/simple
                                   http://www.xiaoxize.com/schema/simple.xsd"
               ... />

        然后发现还是不行：
        java.net.UnknownHostException: www.xiaoxize.com
        org.xml.sax.SAXParseException: schema_reference.4: 无法读取方案文档 'http://www.xiaoxize.com/schema/simple.xsd',
        原因为 1) 无法找到文档; 2) 无法读取文档; 3) 文档的根元素不是 <xsd:schema>。
        Caused by: org.xml.sax.SAXParseException; lineNumber: 21; columnNumber: 91; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 'xiaoxizi:simple' 的声明。

        啊，原来spring解析这个xml的时候，是不归idea管的，他还是会去对应的域名下找这个xsd文件（而我根本没有xiaoxizi这个域名...），
        最后我把xsd文件丢到自己服务器上，并且调整了域名那些，终于可以了：
        SimpleNamespaceHandler ... init()
        SimpleBeanDefinitionParse ... getBeanClassName()
        MyAnnoClass(username=xiaoxizi)
    四、总结
        1. 自定义标签解析过程

            1.第一个自定义标签开始解析时，将会从所有jar包的META-INF/spring.handlers文件加载
             自定义标签命名空间-对应NamespaceHandler全限定名到内存中的DefaultNamespaceHandlerResolver.handlerMappings
            2.同样前缀的自定义标签第一次解析时，将会实例化对应的NamespaceHandler，并调用其init()方法，]
            然后把自定义标签命名空间-对应NamespaceHandler实例放入handlerMappings，下次再有同样的标签过来解析，就直接能拿到对应的NamespaceHandler实例了
            3.使用找到的NamespaceHandler实例的parse方法解析自定义标签
            4.spring贴心的为我们准备了NamespaceHandler相关的模版类NamespaceHandlerSupport，
            如果我们自定义的处理器继承了这个模版，那只需要在init方法中为具体的标签注入相应的BeanDefinitionParser或者BeanDefinitionDecorator就可以实现功能了
        2. context:component-scan做了什么
            1.自定义标签context:component-scan对应的解析器是ComponentScanBeanDefinitionParser（找的过程我们不赘述了）。
            2.解析器的parse方法中，我们通过标签配置的属性创建了一个扫描器ClassPathBeanDefinitionScanner
            3.默认情况下， 我们会注册一个@Component注解的AnnotationTypeFilter，并且注册到扫描器的includeFilters中
            4.然后扫描器开始扫描basePackage下所有的java类，并且找到所有不需要排除（excludeFilters）的候选类（includeFilters），
            5.然后为其生成一个beanDefinition，如果该类是一个合法的beanDefinition（非接口那些判断），那么就会将这些beanDefinition收集起来并返回
            6.对于所有的候选beanDefinition，扫描器还会进一步扫描类上的@Lazy、@Primary、@DependsOn等属性，然后设值到beanDefinition的对应属性中
            7.最后一步，把我们所有扫描到的所有合法的beanDefinition注册到IOC容器
            8.由于@Component是@Service、@Controller等注解的源注解，所以@Service这些注解标记的类也会被includeFilters扫描到
            注册一系列对@Configuration、@Autowired、@Resource等注解进行支撑的Processor

三.逐行解读Spring（三） - 纯注解启动spring的秘密！
    一、前言
        上一篇我们有讲到使用context:component-scan标签，注册扫描器之后，
        扫描器可以把目标包下面有符合过滤器条件（默认情况下会注册一个@Component注解的AnnotationTypeFilter）的类封装成beanDefinition并且注册到IOC容器中来。
        而对于@Configuration，@Bean注解的支持，上一篇只是简单的讲了一下他注册了一个ConfigurationClassPostProcessor的beanDefinition到IOC容器中来，
        这一篇我们就主要讲一下ConfigurationClassPostProcessor的工作原理。

    二、关于BeanPostProcessor和BeanFactoryPostProcessor
        Spring设计时，留下了很多拓展点，这些预留的拓展点可以再之后Spring/用户需要添加新的功能时，可以不需要改动到主流程。而这些特定的拓展点可以大致分为两类：
        BeanFactoryPostProcessor：BeanFactoryPostProcessor和其子接口，这一类拓展点主要是在Spring容器相关的时机被调用的。
        BeanPostProcessor：BeanPostProcessor和其子接口，这一类拓展点主要是在bean的整个生命周期中被调用。

        而我们的ConfigurationClassPostProcessor：
        public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, xxx {}

        public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {
            void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;

        }
        可以看到我们的ConfigurationClassPostProcessor也是BeanFactoryPostProcessor的派生类。



    三、BeanFactoryPostProcessor调用时机
        我们回到容器启动时的refresh()方法（具体是AbstractApplicationContext#refresh）:
        public void refresh() throws BeansException, IllegalStateException {
            synchronized (this.startupShutdownMonitor) {
                prepareRefresh();
                // 上两篇已经讲过了，这里是xml解析的入口
                // Tell the subclass to refresh the internal bean factory
                ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
                // 这里对beanFactory做了一些预处理，感兴趣的同学可以去看下，逻辑不复杂
                // Prepare the bean factory for use in this context.
                prepareBeanFactory(beanFactory);
                // 为子类预留的一个钩子方法
                // Allows post-processing of the bean factory in context subclasses.
                postProcessBeanFactory(beanFactory);
                // !!! 调用BeanFactoryPostProcessor，这一篇我们主要讲这里!!!
                // Invoke factory processors registered as beans in the context.
                invokeBeanFactoryPostProcessors(beanFactory);
                // skip ...
            }
        }
        可以看到，在beanFactory准备好后，我们有一个很明显的方法用来调用BeanFactoryPostProcessor，我们点进去看一下逻辑：
        protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
            PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
            // skip ...
        }
        可以看到，我们把具体逻辑又代理给了PostProcessorRegistrationDelegate来处理，这里其实就是把注册PostProcessor的调用逻辑聚合到一个类里面了而已，我们继续跟下去看看：
        public static void invokeBeanFactoryPostProcessors(
            ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessorPostProcessors) {
        	// 保存所有调用过的PostProcessor的beanName
            Set<String> processedBeans = new HashSet<>();
        	// 如果这个beanFactory也是一个BeanDefinitionRegistry的话，我们也需要调用
            // BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor的方法
            // 正常都是会走这个分支的，因为我们默认的DefaultListableBeanFactory实现了BeanDefinitionRegistry接口
            if (beanFactory instanceof BeanDefinitionRegistry) {
                BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
                // 这两个list主要用来分别收集BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor
                List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
                List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();
        		// 首先我们先把传入的BeanFactoryPostProcessor实例分类-beanFactory初始化的时候
                // 会注册一下实例到AbstractApplicationContext#beanFactoryPostProcessors这个列表，
                // 这个列表的值也是这个方法的第二个入参
                for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
                    if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                        BeanDefinitionRegistryPostProcessor registryProcessor =
                            (BeanDefinitionRegistryPostProcessor) postProcessor;
                        // 对于已经注册到spring的beanFactoryPostProcessors的registryProcessor，直接调用
                        // 优先级最高
                        registryProcessor.postProcessBeanDefinitionRegistry(registry);
                        registryProcessors.add(registryProcessor);
                    }
                    else {
                        regularPostProcessors.add(postProcessor);
                    }
                }
                // 一个中间容器，用来保存当前需要调用的registryProcessor
                List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();
                // 接下来我们需要先把我们注册的beanDefinition中实现了BeanDefinitionRegistryPostProcessor接口的类的名称找出来，
                // 注意，这里不会直接实例化这个bean（主要是这些PostProcessor需要按顺序初始化和调用，先调用的PostProcessor是可能对后初始化的bean造成影响的）
                String[] postProcessorNames =
                    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                // 我们找出所有实现了PriorityOrdered接口的PostProcessor
                for (String ppName : postProcessorNames) {
                    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                        // 这里直接创建了这个registryProcessor的实例，并且加入当前需要处理的容器
                        // beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)
                        // 逻辑之后讲bean生命周期的时候会系讲，这里先略过
                        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                        // 标记为已处理
                        processedBeans.add(ppName);
                    }
                }
                // 对所有实现了PriorityOrdered接口的PostProcessor排序
                sortPostProcessors(currentRegistryProcessors, beanFactory);
                // 加入registryProcessors列表
                registryProcessors.addAll(currentRegistryProcessors);
                // 调用BeanDefinitionRegistryPostProcessor的方法，我们的ConfigurationClassPostProcessor的逻辑就是在这里被调用的
                invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
                // 清除currentRegistryProcessors
                currentRegistryProcessors.clear();

                // 接下来处理实现了Ordered接口的BeanDefinitionRegistryPostProcessor
                // 逻辑就不讲了，跟上面是一样的
                postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                for (String ppName : postProcessorNames) {
                    if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
                        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                        processedBeans.add(ppName);
                    }
                }
                sortPostProcessors(currentRegistryProcessors, beanFactory);
                registryProcessors.addAll(currentRegistryProcessors);
                invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
                currentRegistryProcessors.clear();

                // 接下来处理普通的，没实现排序接口的BeanDefinitionRegistryPostProcessor
                // 需要主要的是，这里有一个循环，主要原因是BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)方法是传入了一个BeanDefinitionRegistry的
                // 这意味着我们可以在（实际上正常实现这个接口就是为了注册beanDefinition的）这个PostProcessor注册新的beanDefinition
                // 而新注册的beanDefinition对应的类也是可能实现BeanDefinitionRegistryPostProcessor接口的，所以这里需要循环处理，知道不会注册新的BeanDefinitionRegistryPostProcessor为止
                boolean reiterate = true;
                while (reiterate) {
                    reiterate = false;
                    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                    for (String ppName : postProcessorNames) {
                        if (!processedBeans.contains(ppName)) {
                            // 如果还有未处理的BeanDefinitionRegistryPostProcessor，则实例化它们
                            // 并且把标记需要在循环一次，因为之后新的BeanDefinitionRegistryPostProcessor的调用可能注册新的BeanDefinitionRegistryPostProcessor
                            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                            processedBeans.add(ppName);
                            reiterate = true;
                        }
                    }
                    // 排序、收集、调用一条龙
                    sortPostProcessors(currentRegistryProcessors, beanFactory);
                    registryProcessors.addAll(currentRegistryProcessors);
                    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
                    currentRegistryProcessors.clear();
                }

                // 所有的BeanDefinitionRegistryPostProcessor都调用完了，接下来要调用BeanFactoryPostProcessor的逻辑了
                // 由于BeanDefinitionRegistryPostProcessor是继承BeanFactoryPostProcessor的，所以这里registryProcessors也需要调用
                invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
                invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
            }
            else {
                // 如果当前beanFactory没有实现BeanDefinitionRegistry接口，则这里只需要调用BeanFactoryPostProcessor的逻辑就行了
                invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
            }

            // 接下来是处理注册了beanDifinition而没有实例化的BeanFactoryPostProcessor的逻辑，
            这里逻辑和处理BeanDefinitionRegistryPostProcessor基本是一样的，都是按顺序初始化（PriorityOrdered->Ordered->None），然后排序，调用的流程
            // 只是没有了循环的逻辑，因为从设计上来讲，BeanFactoryPostProcessor#postProcessBeanFactory里不应当负责beanDefinition的注册的逻辑的，
            所以也不会产生新的beanDifinition，所以这里就不需要循环处理了。
            // 你当然可以在postProcessBeanFactory逻辑里把beanFactory强转成BeanDefinitionRegistry并且注册一些BeanFactoryPostProcessor的beanDefinition，
            导致这里解析不全，可是，我们为什么要跟自己过不去呢？
        }
        可以看到，invokeBeanFactoryPostProcessors的代码虽然比较多，但是逻辑并不复杂。
        我们先是处理了BeanDefinitionRegistryPostProcessor的逻辑，而处理的顺序则是：
        1.已创建实例的registryPostProcessor-->只注册了beanDefinition，尚未创建实例的registryPostProcessor
        2.对于已创建实例的registryPostProcessor，按照他们加入到AbstractApplicationContext#beanFactoryPostProcessors列表的顺序执行
        3.对于未实例化的registryPostProcessor，按照 实现了PriorityOrdered接口的-->实现了Ordered接口的-->未实现排序接口 的顺序 分批创建实例、排序、执行。执行完一批再创建实例、排序、执行下一批。
        4.最后处理未实现排序接口的registryPostProcessor，需要有一个循环处理，保证registryPostProcessor逻辑中新注册的registryPostProcessor的beanDefinition也执行到。

        接下来我们处理了BeanFactoryPostProcessor的逻辑，这个逻辑和BeanDefinitionRegistryPostProcessor的处理逻辑基本上是一致的，只是不需要做第四点循环的逻辑了。
        而调用invokeBeanDefinitionRegistryPostProcessors和invokeBeanFactoryPostProcessors具体又是怎么实现的呢？

        private static void invokeBeanDefinitionRegistryPostProcessors(
            Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry) {

            for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
                postProcessor.postProcessBeanDefinitionRegistry(registry);
            }
        }

        private static void invokeBeanFactoryPostProcessors(
            Collection<? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory) {

            for (BeanFactoryPostProcessor postProcessor : postProcessors) {
                postProcessor.postProcessBeanFactory(beanFactory);
            }
        }

    四、ConfigurationClassPostProcessor工作原理
        之前我们有说过，@Configuration、@Bean注解的功能是通过ConfigurationClassPostProcessor进行支撑的，那么我们接下来看一下ConfigurationClassPostProcessor的逻辑。
        首先带大家回忆一下ConfigurationClassPostProcessor是何时注册到IOC容器的，我们再解析context:component-scan标签时，创建扫描器并扫描类之后，会注册一些公共组件：
        // ComponentScanBeanDefinitionParser#parse
        public BeanDefinition parse(Element element, ParserContext parserContext) {
            String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);
            basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
            String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,
                                                                      ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
        	// 创建扫描器并扫描
            ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);
            Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);
            // 注册组件
            registerComponents(parserContext.getReaderContext(), beanDefinitions, element);
            return null;
        }

        protected void registerComponents(
        			XmlReaderContext readerContext, Set<BeanDefinitionHolder> beanDefinitions, Element element) {
            // ...
        	// 是否开启注解，默认就是开启的
            boolean annotationConfig = true;
            if (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) {
                annotationConfig = Boolean.parseBoolean(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE));
            }
            if (annotationConfig) {
                // 这里注册了一写支持注解的属性
                Set<BeanDefinitionHolder> processorDefinitions =
                    AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);
        		// ...
            }
            // ...
        }
        在AnnotationConfigUtils#registerAnnotationConfigProcessors中，我们把ConfigurationClassPostProcessor包装成beanDefinition并注册进来了：
        // 如果不存在beanName为AnnotationConfigUtils#CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME
        // 的beanDefinition，则注册一个新的
        if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
            RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
            def.setSource(source);
            beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
        }

        由于ConfigurationClassPostProcessor是实现BeanDefinitionRegistryPostProcessor接口的，
        那我们结合AbstractApplicationContext#invokeBeanFactoryPostProcessors中的逻辑可以知道，
        beanFactory初始化之后，会先调用到ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法，我们看一下这个方法的逻辑：

        public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
            // skip ...
            processConfigBeanDefinitions(registry);
        }
        继续往下跟

        public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
            List<BeanDefinitionHolder> configCandidates = new ArrayList<>();
            // 拿到当前registry中所有已经注册的beanDefinition的名称
            String[] candidateNames = registry.getBeanDefinitionNames();
        	// 过滤所有的beanDefinition，把未被处理过的配置类收集起来
            for (String beanName : candidateNames) {
                BeanDefinition beanDef = registry.getBeanDefinition(beanName);
                // 如果beanDefinition中有这个ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE属性，说明这个beanDefinitiony是一个配置类，且已经被处理过了，不需要再处理
                if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {
                    // only log
                }
                // !!!判断当前beanDefinition是不是一个配置类，如果是，收集起来!!!
                else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
                    // 如果是一个需要处理的配置类，加入列表
                    configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
                }
            }
        	// 完全没找到待处理的ConfigurationClass，就直接返回了
            if (configCandidates.isEmpty()) {
                return;
            }

            // 排序
            configCandidates.sort((bd1, bd2) -> {
                int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
                int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
                return Integer.compare(i1, i2);
            });

            // 这里主要是初始化一些工具类，环境变量之类的
            SingletonBeanRegistry sbr = null;
            if (registry instanceof SingletonBeanRegistry) {
                sbr = (SingletonBeanRegistry) registry;
                if (!this.localBeanNameGeneratorSet) {
                    BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(
                        AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);
                    if (generator != null) {
                        this.componentScanBeanNameGenerator = generator;
                        this.importBeanNameGenerator = generator;
                    }
                }
            }
            if (this.environment == null) {
                this.environment = new StandardEnvironment();
            }

            // 创建一个ConfigurationClassParser
            ConfigurationClassParser parser = new ConfigurationClassParser(
                this.metadataReaderFactory, this.problemReporter, this.environment,
                this.resourceLoader, this.componentScanBeanNameGenerator, registry);

            Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
            Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
            do {
                // !!!委托给Parser来解析这些配置类!!!
                // 这里主要是把配置类上的注解信息解析封装成ConfigurationClass对象
                // 如果是配置类导入（入import/componentScan）的普通类（非配置类），将会在这里生成beanDefinition并注册
                parser.parse(candidates);
                // 校验扫描出来的beanDefinitionu是否合法，这里其实主要是校验
                // 1.proxyBeanMethods=true的情况下配置类是否可以重新（非final，需要生成cglib代理类）
                // 2.@Bean修饰的方法是否可以重写（非final，需要生成cglib代理类）
                parser.validate();

                Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
                configClasses.removeAll(alreadyParsed);
        		// 初始化一个ConfigurationClassBeanDefinitionReader
                if (this.reader == null) {
                    this.reader = new ConfigurationClassBeanDefinitionReader(
                        registry, this.sourceExtractor, this.resourceLoader, this.environment,
                        this.importBeanNameGenerator, parser.getImportRegistry());
                }
                // !!!把封装好的ConfigurationClass对象委托给BeanDefinitionReader处理!!!
                // 通过配置类加载注册beanDefinition
                this.reader.loadBeanDefinitions(configClasses);
                alreadyParsed.addAll(configClasses);

                candidates.clear();
                // 处理完ConfigurationClass后，可能会注册新的配置类，这里就是收集这些新注册的配置类的
                if (registry.getBeanDefinitionCount() > candidateNames.length) {
                    String[] newCandidateNames = registry.getBeanDefinitionNames();
                    Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));
                    Set<String> alreadyParsedClasses = new HashSet<>();
                    for (ConfigurationClass configurationClass : alreadyParsed) {
                        alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
                    }
                    for (String candidateName : newCandidateNames) {
                        // 只有新注册的beanDefinition才需要处理
                        if (!oldCandidateNames.contains(candidateName)) {
                            BeanDefinition bd = registry.getBeanDefinition(candidateName);
                            // 是否是配置类且未处理过
                            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&
                                !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                                candidates.add(new BeanDefinitionHolder(bd, candidateName));
                            }
                        }
                    }
                    candidateNames = newCandidateNames;
                }
            }
            // 循环，直到没有新增的配置类为止
            while (!candidates.isEmpty());

            // skip ...
        }

        通过以上源码，我们大体知道了处理配置类的流程，接下来我们重点看一下几个重要的细节

        1. 判断某个类是否是一个配置类
            processConfigBeanDefinitions方法中我们主要是对配置类进行处理的逻辑，那么什么是配置类呢？
            有的同学可能要说了，这还不简单么，就是@Configuration注解修饰的类呀！
            这种说法没错，但是不全，那么我们来看下ConfigurationClassUtils#checkConfigurationClassCandidate方法中是怎么判断一个类是配置类的：
            public static boolean checkConfigurationClassCandidate(
                BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
                String className = beanDef.getBeanClassName();
                // 首先如果这个bean是通过factoryMethod来注册的，那它就不是一个配置类
                if (className == null || beanDef.getFactoryMethodName() != null) {
                    return false;
                }

                AnnotationMetadata metadata;
                // skip ... 这里跳过了一些获取AnnotationMetadata的逻辑，我们只需要知道
                // 这个AnnotationMetadata能拿到类上的所有注解的信息就可以了
            	// 获取类上@Configuration注解的属性
                Map<String, Object> config = metadata.getAnnotationAttributes(Configuration.class.getName());
                // 有@Configuration注解且注解的proxyBeanMethods=true(这个是默认值)
                // 这里解释一下这个proxyBeanMethods属性，这个属性我之前也没有注意，看注解是说如果这个属性为true
                // 则这个配置类里被@Bean注解修饰的方法会被spring代理，使我们通过方法调用的时候获取到的实例也是属于spring管理的。
                if (config != null && !Boolean.FALSE.equals(config.get("proxyBeanMethods"))) {
                    // 注意这里在beanDefinition中塞入了CONFIGURATION_CLASS_ATTRIBUTE这个属性
                    // 外面是通过判断这个是否有属性来确定某个beanDefinition是否是配置类
                    beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
                }
                // 有@Configuration 或者 isConfigurationCandidate(metadata)
                else if (config != null || isConfigurationCandidate(metadata)) {
                    beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
                }
                else {
                    return false;
                }

                // 获取排序值
                Integer order = getOrder(metadata);
                if (order != null) {
                    beanDef.setAttribute(ORDER_ATTRIBUTE, order);
                }

                return true;
            }
            我们可以看到，类上有@Configuration的类确实是属于配置类的，但是，没有@Configuration的时候，
            只要isConfigurationCandidate方法返回true，也是认为这个类是配置类的，我们看一下这个方法：
            public static boolean isConfigurationCandidate(AnnotationMetadata metadata) {
                // Do not consider an interface or an annotation...
                if (metadata.isInterface()) {
                    return false;
                }
                // 类上是否有被candidateIndicators列表中任一注解修饰？
                for (String indicator : candidateIndicators) {
                    if (metadata.isAnnotated(indicator)) {
                        return true;
                    }
                }
                try {
                    // 类中是否包含@Bean注解修饰的方法
                    return metadata.hasAnnotatedMethods(Bean.class.getName());
                }
                catch (Throwable ex) {
                    return false;
                }
            }

            那么这个ConfigurationClassUtils#candidateIndicators中包含哪些注解呢？
            private static final Set<String> candidateIndicators = new HashSet<>(8);
            static {
                candidateIndicators.add(Component.class.getName());
                candidateIndicators.add(ComponentScan.class.getName());
                candidateIndicators.add(Import.class.getName());
                candidateIndicators.add(ImportResource.class.getName());
            }
            那么我们知道了当一个类被@Configuration、@Component、@ComponentScan、@Import、@ImportResource修饰，
            或者类中有@Bean注解修饰的方法时，spring就认为这个类是一个配置类（有@Component注解的话我们基本上可以认为大部分beanDefinition都会被这个PostProcessor处理）。

        2. 解析配置类上的配置信息
            a.ConfigurationClass结构
                刚刚我们有看到，spring把配置类的信息解析并且封装到了ConfigurationClass对象里面，那么我们先看一下这个类的结构是怎样的：
                final class ConfigurationClass {
                	// 配置类的注解信息
                    private final AnnotationMetadata metadata;

                    private final Resource resource;

                    @Nullable
                    private String beanName;
                	// 当前类是哪个配置类导入的
                    private final Set<ConfigurationClass> importedBy = new LinkedHashSet<>(1);
                	// 这个配置类中被@Bean注解标记的方法
                    private final Set<BeanMethod> beanMethods = new LinkedHashSet<>();
                	// 配置类上的@ImportResource 注解中的消息，配置文件地址-对应处理器Class
                    private final Map<String, Class<? extends BeanDefinitionReader>> importedResources =
                        new LinkedHashMap<>();
                	// 配置类上的@Import 注解导入的类，如果是实现了ImportBeanDefinitionRegistrar接口，将会封装到这里
                    private final Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> importBeanDefinitionRegistrars =
                        new LinkedHashMap<>();

                    // 这里重新了equals和hashCode方法，只要配置类的全类名相等这边就认为两个对象一致了。
                    @Override
                    public boolean equals(@Nullable Object other) {
                        return (this == other || (other instanceof ConfigurationClass &&
                                                  getMetadata().getClassName().equals(((ConfigurationClass) other).getMetadata().getClassName())));
                    }
                    @Override
                    public int hashCode() {
                        return getMetadata().getClassName().hashCode();
                    }
                }
            b.ConfigurationClassParser#processConfigurationClass处理配置类的入口
                ConfigurationClassParser#parse方法中经过简单的封装之后会跳转到
                ConfigurationClassParser#processConfigurationClass，我们直接看一下这个方法的逻辑：

                private final Map<ConfigurationClass, ConfigurationClass> configurationClasses = new LinkedHashMap<>();
                protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {
                    // 这里是判断@Condition那些，看是否需要跳过
                    if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
                        return;
                    }
                    // 看一下这个配置类是否已经解析过了，configurationClasses是一个Map
                    // 这里相当于是通过配置类的类名去获取配置类的封装信息的
                    ConfigurationClass existingClass = this.configurationClasses.get(configClass);
                    if (existingClass != null) {
                        // 如果已经解析过，会做一些处理，这里可能会直接返回，即本次就不再解析了
                        // 这里的处理逻辑不太重要，我们不看了
                    }

                    // 这里把configClass又包装成了一个SourceClass， 这个filter的值默认是 DEFAULT_EXCLUSION_FILTER，意思就是这两个包内的类在解析的时候会被排除
                    // private static final Predicate<String> DEFAULT_EXCLUSION_FILTER = className ->(className.startsWith("java.lang.annotation.") || className.startsWith("org.springframework.stereotype."));
                    SourceClass sourceClass = asSourceClass(configClass, filter);
                    // 处理配置类时，处理完当前类之后，还会往上处理它的父类，直到父类是Object就不再处理了
                    // 这个循环就是做这个作用的
                    do {
                        // 处理配置类的逻辑，配置类中的信息将会被封装到configClass
                        sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
                    }
                    while (sourceClass != null);
                    // 把解析后的配置类信息储存到configurationClasses，这里这个key可以认为就是一个类名
                    this.configurationClasses.put(configClass, configClass);
                }
                真正的处理逻辑还在doProcessConfigurationClass中，我们继续跟：
                protected final SourceClass doProcessConfigurationClass(
                    ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)
                    throws IOException {

                    if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
                        // 如果配置类被@Component修饰，先处理内部类
                        processMemberClasses(configClass, sourceClass, filter);
                    }

                    // 这里是处理配置类上的@PropertySources注解的
                    // 简单来说就是把properties文件中的内容加载到内存中的Environment中了
                    // 我们不细看
                    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
                        sourceClass.getMetadata(), PropertySources.class,
                        org.springframework.context.annotation.PropertySource.class)) {
                        if (this.environment instanceof ConfigurableEnvironment) {
                            processPropertySource(propertySource);
                        }
                        else {
                            logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +
                                        "]. Reason: Environment must implement ConfigurableEnvironment");
                        }
                    }

                    // 这里开始是处理类上的@ComponentScan注解的逻辑
                    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
                        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
                    if (!componentScans.isEmpty() &&
                        !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
                        // 循环处理每一个注解（可以用@ComponentScans包装多个注解-jdk<java8，或者直接打上多个@ComponentScan注解-jdk>=java8）
                        for (AnnotationAttributes componentScan : componentScans) {
                            // 委托给componentScanParser处理，这里处理完之后返回了一批已注册的BeanDefinition
                            // 这里的parse逻辑其实就是创建了一个扫描器并且进行扫描，毕竟这个注解就是做这个事的。
                            // 我们之后会看一下
                            Set<BeanDefinitionHolder> scannedBeanDefinitions =
                                this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
                            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                                if (bdCand == null) {
                                    bdCand = holder.getBeanDefinition();
                                }
                                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                                    // 如果扫描出来的类是配置类，需要走一遍解析配置类的逻辑
                                    // 实际上是一个递归
                                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                                }
                            }
                        }
                    }

                    // 处理@Import注解
                    processImports(configClass, sourceClass, getImports(sourceClass), filter, true);

                    // 处理@ImportResource注解
                    AnnotationAttributes importResource =
                        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
                    if (importResource != null) {
                        String[] resources = importResource.getStringArray("locations");
                        // 这个值默认是 BeanDefinitionReader.class
                        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");
                        for (String resource : resources) {
                            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
                            // 把@ImportResource注解上的信息封装到configClass
                            configClass.addImportedResource(resolvedResource, readerClass);
                        }
                    }

                    // 处理有@Bean注解的方法
                    // 这里找到类里所有有@Bean注解修饰的方法
                    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
                    for (MethodMetadata methodMetadata : beanMethods) {
                        // 封装成BeanMethod并且也放入configClass
                        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
                    }
                    // 由于java8之后接口也可以有默认方法（default修饰的方法）
                    // 这里会找到所有接口中被@Bean修饰的非抽象的方法，也封装成BeanMethod放入configClass
                    processInterfaces(configClass, sourceClass);

                    // 如果有父类的话，会返回父类的sourceClass，继续在外层循环中解析
                    // 并且把解析的信息封装到当前这个configClass
                    if (sourceClass.getMetadata().hasSuperClass()) {
                        String superclass = sourceClass.getMetadata().getSuperClassName();
                        if (superclass != null && !superclass.startsWith("java") &&
                            !this.knownSuperclasses.containsKey(superclass)) {
                            this.knownSuperclasses.put(superclass, configClass);
                            // Superclass found, return its annotation metadata and recurse
                            return sourceClass.getSuperClass();
                        }
                    }

                    // 没有父类了就处理完了
                    return null;
                }
            c.处理@Component注解
                进入doProcessConfigurationClass方法时，我们最开始就会处理@Component注解：
                if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
                    // 如果配置类被@Component修饰，先处理内部类
                    processMemberClasses(configClass, sourceClass, filter);
                }
                我们来看一下processMemberClasses的逻辑：
                private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass,
                                                  Predicate<String> filter) throws IOException {
                    // 获取所有的内部类
                    Collection<SourceClass> memberClasses = sourceClass.getMemberClasses();
                    if (!memberClasses.isEmpty()) {
                        List<SourceClass> candidates = new ArrayList<>(memberClasses.size());
                        // 循环处理每个内部类
                        for (SourceClass memberClass : memberClasses) {
                            // 如果内部类也是一个配置类，且内部类与当前类不一致（其实我也不知道为什么会有这种情况？）
                            // 则加入待处理的配置类列表
                            if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&
                                !memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {
                                candidates.add(memberClass);
                            }
                        }
                        // 对待处理的配置类排序
                        OrderComparator.sort(candidates);
                        // 循环按顺序处理每个配置类
                        for (SourceClass candidate : candidates) {
                            // 这里是判断是否有循环import的配置类的，如果有循环导入会直接报错
                            if (this.importStack.contains(configClass)) {
                                this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
                            }
                            else {
                                this.importStack.push(configClass);
                                try {
                                    // 把每一个内部类也需要处理一下，这里其实又回到上层了，是一个递归
                                    processConfigurationClass(candidate.asConfigClass(configClass), filter);
                                }
                                finally {
                                    this.importStack.pop();
                                }
                            }
                        }
                    }
                }
                可以看到，处理配置类上的@Component注解，实际上就是获取到配置类中的所有内部类，并且解析其中的配置类，即调用processConfigurationClass方法。

                d.处理@ComponentScan注解

                @ComponentScan的作用是扫描类上的@Component注解，这个功能是不是跟我们context:component-scan标签的功能有点像呢？
                其实，他们在扫描阶段的功能也确实是一致的。可以看到，我们在处理@ComponentScan注解时，是委托给componentScanParser处理的：
                Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());

                我们来看一下这个ComponentScanAnnotationParser#parse的逻辑：

                public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {
                    // 第一行就创建了一个扫描器Scanner
                    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
                                                                                                componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);

                    // skip ... 中间就是解析了@ComponentScan注解中的信息，并通过这些配置信息配置scanner的属性
                    // 这些信息其实跟自定义标签context:component-scan中的属性/子标签是对应的，有兴趣的同学可以看一下我的上一篇博客
                    // 新增了一个ExcludeFilter，意思就是扫描的时候就不需要处理当前类了-毕竟当前类已经在处理了。
                    scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
                        @Override
                        protected boolean matchClassName(String className) {
                            return declaringClass.equals(className);
                        }
                    });
                    // 扫描器扫描~
                    return scanner.doScan(StringUtils.toStringArray(basePackages));
                }

                哈哈，可以看到，这里就是创建了一个扫描器，然后进行扫描了，逻辑跟我们context:component-scan的扫描过程是一致的，这里就不再跟了。
                需要注意的是，扫描器扫描出来的beanDifinition，如果也是配置类的话，会调用parse方法解析这个配置类，最后又会走到processConfigurationClass方法进行处理：

                for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                    BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                    if (bdCand == null) {
                        bdCand = holder.getBeanDefinition();
                    }
                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                        // 递归解析扫描出来的配置类
                        parse(bdCand.getBeanClassName(), holder.getBeanName());
                    }
                }
            e.处理@Import注解
                @Import注解一般用来引入第三方jar包的类到spring容器，当然@bean也有这个功能，
                但是@Import与@Bean不一样的地方是，@Import是用来修饰类的，spring中很多@EnableXxx的注解就是通过@Import的功能实现的，我们现在就来看下它的处理过程：
                processImports(configClass, sourceClass, getImports(sourceClass), filter, true);
                getImports()是用来收集所有@import导入的类的，我们看一下这个收集逻辑：
                private Set<SourceClass> getImports(SourceClass sourceClass) throws IOException {
                    //  用来保存import导入的类
                    Set<SourceClass> imports = new LinkedHashSet<>();
                    // 用来标记哪些类是已经处理过的
                    Set<SourceClass> visited = new LinkedHashSet<>();
                    // 递归收集
                    collectImports(sourceClass, imports, visited);
                    return imports;
                }

                private void collectImports(SourceClass sourceClass, Set<SourceClass> imports, Set<SourceClass> visited)
                    throws IOException {
                    // 把当前类标记为已处理过
                    if (visited.add(sourceClass)) {
                        // 拿到并循环处理类上的所有注解
                        for (SourceClass annotation : sourceClass.getAnnotations()) {
                            String annName = annotation.getMetadata().getClassName();
                            // 如果当前类上的这个注解不是@Import
                            if (!annName.equals(Import.class.getName())) {
                                // 则继续递归收集这个注解上的注解（有点绕...）
                                collectImports(annotation, imports, visited);
                            }
                        }
                        // 把当前类上的所有@Import注解的value属性（即import的Class<?>）封装成sourceClass
                        // 并且加入收集到的容器
                        imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"));
                    }
                }

                这里逻辑可能有点绕，不过它的功能就是把我们类上的@Import注解的信息收集起来，并且递归收集注解上的注解，例如我们的@EnableAsync注解：

                @Import(AsyncConfigurationSelector.class)
                public @interface EnableAsync {}

                @Configuration
                @EnableAsync
                public class Test {}

                我们在收集Test上的@Import注解信息的时候，第一次进入collectImports方法时，
                sourceClass=Test，这个时候，除了会收集Test类上的@Import注解信息外，
                还会获取Test类上的其他注解，例如这里有@EnableAsync注解，
                然后把@EnableAsync注解类的信息作为sourceClass（即sourceClass=EnableAsync）继续调用collectImports方法递归收集@Import注解信息，
                这时候EnableAsync上的@Import(AsyncConfigurationSelector.class)注解信息就被收集到了。
                继续往下，我们看一下收集到@Import导入的类之后，~又是怎么处理的：
                private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
                                            Collection<SourceClass> importCandidates, Predicate<String> exclusionFilter,
                                            boolean checkForCircularImports) {
                    // 这里把循环导入的处理逻辑和异常处理逻辑去掉了
                    // 循环每一个@Import导入的类
                    for (SourceClass candidate : importCandidates) {
                        if (candidate.isAssignable(ImportSelector.class)) {
                            // 如果实现了ImportSelector接口
                            // 这里把这个ImportSelector实例化了
                            Class<?> candidateClass = candidate.loadClass();
                            ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,
                                                                                           this.environment, this.resourceLoader, this.registry);
                            Predicate<String> selectorFilter = selector.getExclusionFilter();
                            if (selectorFilter != null) {
                                exclusionFilter = exclusionFilter.or(selectorFilter);
                            }
                            // 这里判断是否是延迟导入，如果是延迟导入的话，会在parse方法中，所有配置类都处理完之后再处理，有兴趣的同学可以自己看一下
                            // 具体代码在ConfigurationClassParser#parse(java.util.Set<org.springframework.beans.factory.config.BeanDefinitionHolder>)
                            if (selector instanceof DeferredImportSelector) {
                                this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);
                            }
                            else {
                                // 如果是一个普通的ImportSelector
                                String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                                Collection<SourceClass> importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);
                                // 调用ImportSelector.selectImports方法，将获取到的类名作为参数递归调用当前方法
                                // 也就是说这个ImportSelector接口和@Import注解实现的功能是一样的
                                // 估计@Import是spring支持注解之后对ImportSelector接口做的注解版吧
                                processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false);
                            }
                        }
                        else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
                            // 如果导入的类实现了ImportBeanDefinitionRegistrar接口
                            // 这里也会把这个类先实例化
                            Class<?> candidateClass = candidate.loadClass();
                            ImportBeanDefinitionRegistrar registrar =
                                ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,
                                                                     this.environment, this.resourceLoader, this.registry);
                            // 然后加入到当前配置类的属性中了
                            configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
                        }
                        else {
                            // 如果导入的类既没实现ImportSelector接口，又没实现ImportBeanDefinitionRegistrar接口
                            // 则认为是一个普通的配置类，进行配置类的处理逻辑
                            processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);
                        }
                    }
                }
                可以看到，对于导入的类，这里有三种处理逻辑：
                1.实现了ImportSelector接口的导入类
                    调用ImportSelector.selectImports方法，将获取到的类名作为参数递归调用当前处理导入类的方法
                    可以说是@Import的接口版
                2.实现ImportBeanDefinitionRegistrar接口
                    实例化为ImportBeanDefinitionRegistrar对象后，放入当前configClass中
                    ImportBeanDefinitionRegistrar接口有一个传入BeanDefinitionRegistry的registerBeanDefinitions方法，
                    不难猜测这个接口是可以用来注册beanDefinition的，这个方法应该只会会调用到。
                3.普通的类：作为普通的配置类，递归调用processConfigurationClass方法进行处理

            f.处理@ImportResource注解
                @ImportResource功能是导入spring的xml配置文件，一般是用来接入一些比较老的，使用xml定义bean的二方库。
                AnnotationAttributes importResource =
                    AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
                if (importResource != null) {
                    String[] resources = importResource.getStringArray("locations");
                    Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");
                    for (String resource : resources) {
                        String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
                        // 这里是直接把配置文件路径和处理类类型放入了configClass对象
                        configClass.addImportedResource(resolvedResource, readerClass);
                    }
                }
            g.处理@Bean注解
                @Bean注解可能是这一批注解中，我们日常用的最多的注解了，我们经常会用他来引入一些三方库的类来让spring管理。我们来看一下parse阶段它的处理逻辑：
                // 收集当前类里所有有@bean注解的方法
                Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
                for (MethodMetadata methodMetadata : beanMethods) {
                    // 封装成BeanMethod对象，加入configClass
                    configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
                }

                // 处理当前类的接口，接口是可能有有默认实现（jdk>=1.8）的@Bean修饰方法
                processInterfaces(configClass, sourceClass);
                收集类上@Bean注解修饰的方法其实很简单，我们正常通过反射就能拿到了，不过spring为了确定这些方法处理的顺序，使用了asm字节码技术来获取方法在类中的声明顺序：
                private Set<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {
                    AnnotationMetadata original = sourceClass.getMetadata();
                    // 获取所有被@Bean修饰的方法
                    Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName());
                    if (beanMethods.size() > 1 && original instanceof StandardAnnotationMetadata) {
                        // Try reading the class file via ASM for deterministic declaration order...
                        // Unfortunately, the JVM's standard reflection returns methods in arbitrary
                        // order, even between different runs of the same application on the same JVM.
                        // 这里注释是说由于jvm返回的方法列表顺序不能保证，这里尝试使用asm字节码技术拿到方法在类中的声明顺序，以此来为这些被@Bean修饰的方法排序
                        try {
                            AnnotationMetadata asm =
                                this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata();
                            Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName());
                            // 排序
                            if (asmMethods.size() >= beanMethods.size()) {
                                Set<MethodMetadata> selectedMethods = new LinkedHashSet<>(asmMethods.size());
                                for (MethodMetadata asmMethod : asmMethods) {
                                    for (MethodMetadata beanMethod : beanMethods) {
                                        if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {
                                            selectedMethods.add(beanMethod);
                                            break;
                                        }
                                    }
                                }
                                if (selectedMethods.size() == beanMethods.size()) {
                                    // All reflection-detected methods found in ASM method set -> proceed
                                    beanMethods = selectedMethods;
                                }
                            }
                        }
                        catch (IOException ex) {
                            logger.debug("Failed to read class file via ASM for determining @Bean method order", ex);
                            // No worries, let's continue with the reflection metadata we started with...
                        }
                    }
                    return beanMethods;
                }
                我们接下来看一下接口的处理逻辑：
                private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {
                    for (SourceClass ifc : sourceClass.getInterfaces()) {
                        // 获取接口上所有被@Bean修饰的方法
                        Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc);
                        for (MethodMetadata methodMetadata : beanMethods) {
                            if (!methodMetadata.isAbstract()) {
                                // A default method or other concrete method on a Java 8+ interface...
                                // 只有不是抽象的方法才封装成BeanMethod加入configClass
                                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
                            }
                        }
                        // 递归处理
                        processInterfaces(configClass, ifc);
                    }
                }
            h.parse方法小结
                可以看到，parser.parse(candidates)的处理逻辑还是蛮复杂的，这个方法基本上对我们平常使用的注解都做了处理，
                而且其中包含大量递归调用的逻辑，我也是看了好多遍才看明白的，感兴趣的同学不妨多看几遍。

        3. 通过配置类加载注册beanDefinition
            配置类解析完之后，我们需要通过配置类的信息来加载注册beanDefinition
            parser.parse(candidates);
            parser.validate();
            // 获取所有解析出来的配置类
            Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
            configClasses.removeAll(alreadyParsed);

            // Read the model and create bean definitions based on its content
            if (this.reader == null) {
                this.reader = new ConfigurationClassBeanDefinitionReader(
                    registry, this.sourceExtractor, this.resourceLoader, this.environment,
                    this.importBeanNameGenerator, parser.getImportRegistry());
            }
            // 加载注册beanDefinition
            this.reader.loadBeanDefinitions(configClasses);
            alreadyParsed.addAll(configClasses);

            我们直接去看一下loadBeanDefinitions的逻辑：
            public void loadBeanDefinitions(Set<ConfigurationClass> configurationModel) {
                TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
                for (ConfigurationClass configClass : configurationModel) {
                    // 循环解析
                    loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
                }
            }

            private void loadBeanDefinitionsForConfigurationClass(
                ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {

                if (trackedConditionEvaluator.shouldSkip(configClass)) {
                    // skip ...
                }

                if (configClass.isImported()) {
                    // 如果是导入的配置类，先把自己的beanDefinition注册到spring
                    // 里面就是一个简单的beanDefinition封装注册的流程，我们就不看了
                    registerBeanDefinitionForImportedConfigurationClass(configClass);
                }
                for (BeanMethod beanMethod : configClass.getBeanMethods()) {
                    // 从beanMethod注册beanDefinition
                    loadBeanDefinitionsForBeanMethod(beanMethod);
                }
            	// 从导入的配置文件注册beanDefinition
                loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
                // 从导入的ImportBeanDefinitionRegistrar注册beanDefinition
                loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
            }
            可以看到，加载注册beanDefinition的逻辑还是蛮清晰的，基本上就是对我们封装到ConfigurationClass对象里的信息逐个加载。接下来我们逐一看一下。

            a.通过BeanMethod加载注册beanDefinition
                BeanMethod对象是配置类中被@Bean注解修饰的方法封装而成，我们看一下它的处理逻辑：
                private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {
                    // 我这里把代码简化了一下，因为一个beanDefinition的封装过程，无非是把@Bean注解中的信息获取封装一遍
                    // 那些信息的封装我们在讲解xml标签的时候已经讲过了，这些属性都是一一对应的
                    // 这里我只把我们需要额外关注的地方写出来了 -- 即我们一般意义上说的@Bean的实现原理
                    ConfigurationClass configClass = beanMethod.getConfigurationClass();
                    MethodMetadata metadata = beanMethod.getMetadata();
                    // skip ...
                    // 新建一个ConfigurationClassBeanDefinition
                    ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);
                    // skip ...
                    // !!!关键点!!!
                    if (metadata.isStatic()) {
                        // 如果是静态的@Bean方法，需要设置beanClass/beanClassName，用于在bean初始化时调用
                        if (configClass.getMetadata() instanceof StandardAnnotationMetadata) {
                            beanDef.setBeanClass(((StandardAnnotationMetadata) configClass.getMetadata()).getIntrospectedClass());
                        }
                        else {
                            beanDef.setBeanClassName(configClass.getMetadata().getClassName());
                        }
                        // 设置FactoryMethodName
                        beanDef.setUniqueFactoryMethodName(methodName);
                    }
                    else {
                        // 如果是非静态的@Bean方法，还需要设置工厂类的beanName
                        beanDef.setFactoryBeanName(configClass.getBeanName());
                        // 设置FactoryMethodName
                        beanDef.setUniqueFactoryMethodName(methodName);
                    }
                    // skip ...
                    // 注册beanDefinition
                    this.registry.registerBeanDefinition(beanName, beanDefToRegister);
                }
                可以看到，我们的@Bean创建的beanDefinition，与普通的beanDefinition不一样的地方在于，
                它是设置了factoryMethodName的，也就是说，他说通过使用xml方式中的factory-bean、factory-method标签的功能，来实现bean的创建的！

            b.通过@ImportedResource注解信息加载注册beanDefinition
                @ImportedResource注解中携带了需要导入的文件的路径，以及文件Reader的信息，所以我们加载注册beanDefinition的时候，也是从这些信息入手的：
                private void loadBeanDefinitionsFromImportedResources(
                			Map<String, Class<? extends BeanDefinitionReader>> importedResources) {
                	// reader实例缓存
                    Map<Class<?>, BeanDefinitionReader> readerInstanceCache = new HashMap<>();
                	// 循环处理<配置文件路径-reader>
                    importedResources.forEach((resource, readerClass) -> {
                        // 如果注解配置的Reader是默认的（我们一般其实也不改）
                        if (BeanDefinitionReader.class == readerClass) {
                            if (StringUtils.endsWithIgnoreCase(resource, ".groovy")) {
                                // 如果文件名是.groovy结尾，则使用GroovyBeanDefinitionReader
                                // 说实话我也第一次知道还可以用groovy脚本来做spring的配置文件
                                // 后面我去看了一下BeanDefinitionReader这个接口的实现类，发现还一个
                                // PropertiesBeanDefinitionReader，感兴趣的同学可以去研究一下
                                readerClass = GroovyBeanDefinitionReader.class;
                            }
                            else {
                                // 默认情况下我们使用XmlBeanDefinitionReader
                                // 有没有点眼熟这个类？xml配置解析的时候就是用的它呀
                                readerClass = XmlBeanDefinitionReader.class;
                            }
                        }
                		// 先从缓存拿
                        BeanDefinitionReader reader = readerInstanceCache.get(readerClass);
                        if (reader == null) {
                            try {
                                // 拿不到就新建一个，配置的reader类必须有一个只有BeanDefinitionRegistry参数的构造器
                                reader = readerClass.getConstructor(BeanDefinitionRegistry.class).newInstance(this.registry);
                                // Delegate the current ResourceLoader to it if possible
                                if (reader instanceof AbstractBeanDefinitionReader) {
                                    AbstractBeanDefinitionReader abdr = ((AbstractBeanDefinitionReader) reader);
                                    abdr.setResourceLoader(this.resourceLoader);
                                    abdr.setEnvironment(this.environment);
                                }
                                readerInstanceCache.put(readerClass, reader);
                            }
                            catch (Throwable ex) {
                                throw new IllegalStateException(
                                    "Could not instantiate BeanDefinitionReader class [" + readerClass.getName() + "]");
                            }
                        }
                		// 使用reader从文件加载bean
                        reader.loadBeanDefinitions(resource);
                    });
                }
                默认情况下（大部分情况我们都不会自行配置BeanDefinitionReader）是创建一个XmlBeanDefinitionReader来解析加载我们的配置文件中定义的bean的，
                这和我们在xml解析那一节讲的内容一样，这里就不在讲了。


            c.通过@Import注解导入的ImportBeanDefinitionRegistrar类加载注册beanDefinition
                当@Import导入的类有实现ImportBeanDefinitionRegistrar接口时，我们会把这个类收集起来，直到这里才会处理：
                private void loadBeanDefinitionsFromRegistrars(Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> registrars) {
                    registrars.forEach((registrar, metadata) ->
                           // 直接调用registerBeanDefinitions方法
                           registrar.registerBeanDefinitions(metadata, this.registry, this.importBeanNameGenerator));
                }
                处理的逻辑也很简单，就是直接调用ImportBeanDefinitionRegistrar.registerBeanDefinitions方法，进行beanDefinition的注册。
                到这里位置，其实整个ConfigurationClassPostProcessor的逻辑我们就讲完了。spring正是通过这个PostProcessor提供了对@Bean，@Import等常见IOC注解的支持。

    五、纯注解启动spring
        刚刚我们一直都在讲ConfigurationClassPostProcessor对注解的支持，
        但是这个组件确是spring在解析xml配置文件中的context:component-scan标签时注入的，
        带同学们回忆一下（通过自定义标签找处理类的逻辑这边就不重复了，感兴趣的同学可以看一下我的上一篇博文）：
        public BeanDefinition parse(Element element, ParserContext parserContext) {
            // 获取标签上配置并处理的base-package属性
            String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);
            // 处理占位符
            basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
            // 最终获取到的是一个数组 - 因为我们配置的时候是可以配置多个的
            String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,
                                                                      ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);

            // 获取一个扫描器 - 这个东西很重要，我们以后还会看到
            ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);
            // 嗯，扫描器进行扫描，看来就是这个方法会扫描那些注解了
            Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);
            // ！！！注册一些组件！！！ 就是这里注入的ConfigurationClassPostProcessor
            registerComponents(parserContext.getReaderContext(), beanDefinitions, element);
            return null;
        }

        protected void registerComponents(
            XmlReaderContext readerContext, Set<BeanDefinitionHolder> beanDefinitions, Element element) {
            // skip ...
            // 默认是true
            if (annotationConfig) {
                // 注意这个AnnotationConfigUtils.registerAnnotationConfigProcessors
                Set<BeanDefinitionHolder> processorDefinitions =
                    AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);
                // skip ...
            }
            // skip ...
        }
        public static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(
            BeanDefinitionRegistry registry, @Nullable Object source) {
            // skip ...
            if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
                // 就是里注册了一个ConfigurationClassPostProcessor
                RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
                def.setSource(source);
                beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
            }
        	// skip ...
        }

        可以看到，我们在解析context:component-scan标签的时候，最终调用AnnotationConfigUtils.registerAnnotationConfigProcessors方法向spring注册了一批支撑注解的组件，其中就有ConfigurationClassPostProcessor。
        那么问题来了，既然我是想通过注解来定义，声明bean，那么我为什么还要有一个xml文件，还要去解析xml中的
        context:component-scan标签呢？有没有一种纯注解的方式，能让我启动spring呢？
        答案当然是有的，不过这个时候我们要使用AnnotationConfigApplicationContext来启动spring了。

        1. 使用AnnotationConfigApplicationContext启动spring
            首先我们定义一个业务类：
            @Data
            @Service
            public class MyAnnoClass {
                public String username = "xiaoxizi";
            }

            然后使用AnnotationConfigApplicationContext启动：
            @Test
            public void test() {
                applicationContext = new AnnotationConfigApplicationContext("com.xiaoxizi.spring");
                MyAnnoClass myAnnoClass = applicationContext.getBean(MyAnnoClass.class);
                System.out.println(myAnnoClass);
            }
            运行结果：MyAnnoClass(username=xiaoxizi)
            spring启动成功，运行结果也符合我们的预期，MyAnnoClass确实被spring管理了。
        2. AnnotationConfigApplicationContext纯注解启动spring原理分析
            话不多说，接下来我们之间分析一下AnnotationConfigApplicationContext支持纯注解启动spring的原理。
            我们先看一下AnnotationConfigApplicationContext的构造器：

            public AnnotationConfigApplicationContext(String... basePackages) {
                // 调用自己的无参构造器
                this();
                // 这个scan，看着就像扫描的意思啊
                scan(basePackages);
                // 这个refresh就是我们常说的spring启动的核心流程了
                refresh();
            }
            // 看一下无参构造器
            public AnnotationConfigApplicationContext() {
                // 创建一个AnnotatedBeanDefinitionReader
                this.reader = new AnnotatedBeanDefinitionReader(this);
                // 创建一个ClassPathBeanDefinitionScanner
                this.scanner = new ClassPathBeanDefinitionScanner(this);
            }

            可以看到，我们的创建AnnotationConfigApplicationContext对象的时候，创建了一个
            AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner。
            等等，这个ClassPathBeanDefinitionScanner是不是好像有点眼熟？
            这不就是我们解析context:component-scan标签的时候创建的那个扫描器么？那么构造器中调用的scan方法的逻辑岂不是...?

            @Override
            public void scan(String... basePackages) {
                Assert.notEmpty(basePackages, "At least one base package must be specified");
                // 使用扫描器扫描
                this.scanner.scan(basePackages);
            }
            你猜的没错，同学，就是通过扫描器去扫描对应的包(╹▽╹)。跟context:component-scan标签的的处理方式一模一样呢。
            那么，到这里为止，我们已经可以把basePackage下的被@Component修饰的类，扫描封装注册到spring了，但是我们好像还没办法处理@Bean等标签，毕竟还没有看到哪里注入ConfigurationClassPostProcessor。
            这个时候就需要往回看了，AnnotationConfigApplicationContext的构造器中，只有一个动作我们是不熟悉的，就是创建AnnotatedBeanDefinitionReader，那么我们来看一下这个类的构造逻辑：

            public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
                this(registry, getOrCreateEnvironment(registry));
            }

            public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
                this.registry = registry;
                this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
                // !!! 注册支持注解的组件 !!!
                AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
            }

            好了，破案了，原来是AnnotatedBeanDefinitionReader在创建的时候，
            会调用AnnotationConfigUtils.registerAnnotationConfigProcessors方法向spring注册了支撑注解的组件，
            其中就有ConfigurationClassPostProcessor。所以我们就能愉快的使用纯注解的方式启动spring啦。

    六、小结


四上.逐行解读Spring（四） - 万字长文讲透bean生命周期（上）
    一、前言
        这些天一直在琢磨bean生命周期这一块应该怎么写，因为这一块的流程实在比较长，而且涉及到很多beanPostProcessor的埋点，
        很多我们常见的功能都是通过这些埋点来做的。
        最终，我决定先用一篇博文，把bean生命周期的主流程较为**粗略（相对）**的讲一下。之后，会通过一系列博文对主流程中的一些细节、
        和一些常见的功能是怎么通过spring预留的beanPostProcessor埋点来实现的。感兴趣的同学可以自己选择查看。

    二、Spring容器的启动
        发现其实到现在，我的这一系列spring博文，都没有好好讲过spring容器启动的过程（第一篇中也是直接给定位到了refresh方法）。
        正好上一篇讲的纯注解启动类AnnotationConfigApplicationContext，这里我们再回顾一下：
        @Test
        public void test() {
            // 我们平常使用AnnotationConfigApplicationContext的时候，只需要这样直接new出来就好了
            applicationContext = new AnnotationConfigApplicationContext("com.xiaoxizi.spring");
            // 然后就可以从容器中拿到bean对象了，说明其实new创建对象的时候，我们容器就做好启动初始化工作了~
            MyAnnoClass myAnnoClass = applicationContext.getBean(MyAnnoClass.class);
            System.out.println(myAnnoClass);
        }

        // AnnotationConfigApplicationContext的构造器
        public AnnotationConfigApplicationContext(String... basePackages) {
            this();
            // 扫描目标包，收集并注册beanDefinition，上一篇具体讲过，这里就不赘述了
            scan(basePackages);
            // 这里就调用到我们大名鼎鼎的refresh方法啦
            refresh();
        }

        我们看一下这个容器启动的核心方法refresh，这个方法的逻辑是在AbstractApplicationContext类中的，也是一个典型的模板方法：
        public void refresh() throws BeansException, IllegalStateException {
            synchronized (this.startupShutdownMonitor) {
                // 一些准备工作，主要是一下状态的设置事件容器的初始化
                prepareRefresh();

                // 获取一个beanFactory，这个方法里面调用了一个抽象的refreshBeanFactory方法
                // 我们的xml就是在这个入口里解析的，具体的流程有在之前的博文分析过
                ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

                // 把拿到的beanFactory做一些准备，这里其实没啥逻辑，同学们感兴趣的可以看下
                // 但是这个方法也是一个protected的方法，
                // 也就是说我们如果实现自己的spring启动类/或者spring团队需要写一个新的spring启动类的时候
                // 是可以在beanFactory获取之后做一些事情的，算是一个钩子
                prepareBeanFactory(beanFactory);

                try {
                    // 这也是一个钩子，在处理beanFactory前允许子类做一些事情
                    postProcessBeanFactory(beanFactory);

                    // 实例化并且调用factoryPostProcessor的方法，
                    // 我们@Compoment等注解的收集处理主要就是在这里做的
                    // 有一个ConfigurationClassPostProcessor专门用来做这些注解支撑的工作
                  	// 这里的逻辑之前也讲过了
                    // 那么其实我们可以说，到这里为止，我们的beanDefinition的收集（注解/xml/其他来源...）
                    // 、注册（注册到beanFactory的beanDefinitionMap、beanDefinitionNames）容器
                    // 工作基本就全部完成了
                    invokeBeanFactoryPostProcessors(beanFactory);

                    // 从这里开始，我们就要专注bean的实例化了
                    // 所以我们需要先实例化并注册所有的beanPostProcessor
                    // 因为beanPostProcessor主要就是在bean实例化过程中，做一些附加操作的（埋点）
                    // 这里的流程也不再讲了，感兴趣的同学可以自己看一下，
                    // 这个流程基本跟FactoryPostProcessor的初始化是一样的，
                    // 排序，创建实例，然后放入一个list --> AbstractBeanFactory#beanPostProcessors
                    registerBeanPostProcessors(beanFactory);

                    // 初始化一些国际化相关的组件，这一块我没有去详细了解过（主要是暂时用不到...）
                    // 之后如果有时间也可以单独拉个博文来讲吧
                    initMessageSource();

                    // 初始化事件多播器，本篇不讲
                    initApplicationEventMulticaster();

                    // 也是个钩子方法，给子类创建一下特殊的bean
                    onRefresh();

                    // 注册事件监听器，本篇不讲
                    registerListeners();

                    // !!!实例化所有的、非懒加载的单例bean
                    // Instantiate all remaining (non-lazy-init) singletons.
                    finishBeanFactoryInitialization(beanFactory);

                    // 初始化结束，清理资源，发送事件
                    finishRefresh();
                }
                catch (BeansException ex) {
                    // 销毁已经注册的单例bean
                    destroyBeans();
                    // 修改容器状态
                    cancelRefresh(ex);
                    // Propagate exception to caller.
                    throw ex;
                }

                finally {
                    // Reset common introspection caches in Spring's core, since we
                    // might not ever need metadata for singleton beans anymore...
                    resetCommonCaches();
                }
            }
        }
        其实说白了，我们spring容器的启动，主要就是要把那些非懒加载的单例bean给实例化，并且管理起来。

    三、bean实例化
        1. 哪些bean需要在启动的时候实例化？
            刚刚refresh方法中，我们有看到finishBeanFactoryInitialization方法是用来实例化bean的，
            并且源码中的英文也说明了，说是要实例化所以剩余的非懒加载的单例bean，那么实际情况真的如此么？我们跟源码看一下：
            protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
            	// skip .. 我把前面的非主流程的跳过了
                // Instantiate all remaining (non-lazy-init) singletons.
                beanFactory.preInstantiateSingletons();
            }

            // DefaultListableBeanFactory#preInstantiateSingletons
            public void preInstantiateSingletons() throws BeansException {
                // 我们之前注册beanDefinition的时候，有把所有的beanName收集到这个beanDefinitionNames容器
                // 这里我们就用到了
                List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

                // 循环所有的已注册的beanName
                for (String beanName : beanNames) {
                    // 获取合并后的beanDefinition，简单来讲，我们的beanDefinition是可以存在继承关系的
                    // 比如xml配置从的parent属性，这种时候，我们需要结合父子beanDefinition的属性，生成一个新的
                    // 合并的beanDefinition，子beanDefinition中的属性会覆盖父beanDefinition的属性，
                    // 并且这是一个递归的过程（父还可以有父），不过这个功能用的实在不多，就不展开了，
                    // 同学们有兴趣可以自行看一下，这里可以就理解为拿到对应的beanDefinition就好了
                    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
                    // 非抽象（xml有一个abstract属性，而不是说这个类不是一个抽象类）、单例的、非懒加载的才需要实例化
                    if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
                        if (isFactoryBean(beanName)) {
                            // 这里是处理factoryBean的，暂时不讲，之后再专门写博文
                            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                            if (bean instanceof FactoryBean) {
                                final FactoryBean<?> factory = (FactoryBean<?>) bean;
                                boolean isEagerInit;
                                if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                                    isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)
                                                                                ((SmartFactoryBean<?>) factory)::isEagerInit,
                                                                                getAccessControlContext());
                                }
                                else {
                                    isEagerInit = (factory instanceof SmartFactoryBean &&
                                                   ((SmartFactoryBean<?>) factory).isEagerInit());
                                }
                                if (isEagerInit) {
                                    getBean(beanName);
                                }
                            }
                        }
                        else {
                            // !!!我们正常普通的bean会走到这个流程，这里就把这个bean实例化并且管理起来的
                            // 这里是获取一个bean，如果获取不到，则创建一个
                            getBean(beanName);
                        }
                    }
                }

                // 所以的bean实例化之后，还会有一些处理
                for (String beanName : beanNames) {
                    // 获取到这个bean实例
                    Object singletonInstance = getSingleton(beanName);
                    // 如果bean实现了SmartInitializingSingleton接口
                    if (singletonInstance instanceof SmartInitializingSingleton) {
                        final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
                        // 会调用它的afterSingletonsInstantiated方法
                        // 这是最外层的一个钩子了，平常其实用的不多
                        // 不过@Listener的发现是在这里做的
                        smartSingleton.afterSingletonsInstantiated();
                    }
                }
            }
            可以看到，原来是非抽象（xml有一个abstract属性，而不是说这个类不是一个抽象类）、单例的、非懒加载的bean才会在spring容器启动的时候实例化

        2. 使用getBean从beanFactory获取bean
            刚刚有说到，调用getBean方法的时候，会先尝试中spring容器中获取这个bean，获取不到的时候则会创建一个，现在我们就来梳理一下这个流程：
            public Object getBean(String name) throws BeansException {
                // 调用了doGetBean
                // 说一下这种方式吧，其实我们能在很多框架代码里看到这种方式
                // 就是会有一个参数最全的，可以最灵活使用的方法，用来处理我们的业务
                // 然后会对不同的使用方，提供一些便于使用的类似于门面的方法，这些方法会简化一些参数，使用默认值填充
                // 或者实际业务可以很灵活，但是不打算完全开放给使用方的时候，也可以使用类似的模式
                return doGetBean(name, null, null, false);
            }

            getBean->doGetBean是我们beanFactory对外提供的获取bean的接口，
            只是说我们初始化spring容器的时候会为所有单例的beanDefinition调用getBean方法实例化它们定义的bean而已，
            所以它的的逻辑并不仅仅是为spring容器初始化定义的，我们也需要带着这个思维去看这个方法：

            protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
                                      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
            	// 转换一下beanName,暂时不看，之后统一讲
                final String beanName = transformedBeanName(name);
                Object bean;

                // 看一下这个bean是否已经实例化了，如果实例化了这里能直接拿到
                // 这个方法涉及到spring bean的3级缓存，之后会开一篇博客细讲
                Object sharedInstance = getSingleton(beanName);
                if (sharedInstance != null && args == null) {
                    // 通过这个bean实例获取用户真正需要的bean实例
                    // 有点绕，其实这里主要是处理当前bean实现了FactoryBean接口的情况的
                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
                }
                else {
                    // 当前线程下的，循环依赖检测，如果当前bean已经在创建中，这里又进来创建了，说明是循环依赖了
                    // 会直接报错，代码逻辑也很简单，这里主要是一个TheadLocal持有了一个set，
                    // 可以认为是一个快速失败检测，和后面的全局循环依赖检测不是一个容器
                    // 容器是 prototypesCurrentlyInCreation
                    if (isPrototypeCurrentlyInCreation(beanName)) {
                        throw new BeanCurrentlyInCreationException(beanName);
                    }


                    BeanFactory parentBeanFactory = getParentBeanFactory();
                    if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
                        // 如果父容器不为空且当前容器没有这个beanName对应的beanDefinition
                        // 则尝试从父容器获取（因为当期容器已经确定没有了）
                        // 下面就是调用父容器的getBean了
                        String nameToLookup = originalBeanName(name);
                        if (parentBeanFactory instanceof AbstractBeanFactory) {
                            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                                nameToLookup, requiredType, args, typeCheckOnly);
                        }
                        else if (args != null) {
                            return (T) parentBeanFactory.getBean(nameToLookup, args);
                        }
                        else if (requiredType != null) {
                            return parentBeanFactory.getBean(nameToLookup, requiredType);
                        }
                        else {
                            return (T) parentBeanFactory.getBean(nameToLookup);
                        }
                    }
            		// 如果不是只检测类型是否匹配的话，这里要标记bean已创建（因为马上就要开始创建了）
                    if (!typeCheckOnly) {
                        markBeanAsCreated(beanName);
                    }

                    try {
                        final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                        checkMergedBeanDefinition(mbd, beanName, args);
            			// 拿到这个bean的所有依赖的bean
                        String[] dependsOn = mbd.getDependsOn();
                        if (dependsOn != null) {
                            // 如果依赖不为空，需要先循环实例化依赖
                            for (String dep : dependsOn) {
                                if (isDependent(beanName, dep)) {
                                    throw new BeanCreationException(...);
                                }
                                registerDependentBean(dep, beanName);
                                try {
                                    getBean(dep);
                                }
                                catch (NoSuchBeanDefinitionException ex) {
                                    throw new BeanCreationException(...);
                                }
                            }
                        }

                        // 这里开始真正创建bean实例的流程了
                        if (mbd.isSingleton()) {
                            // 如果是单例的bean（当然我们启动的时候会实例化的也就是单例bean了），这里会进行创建
                            // 注意这里也是一个getSingleton方法，跟之前那个getSingleton方法差不多，不过这里是
                            // 如果获取不到就会使用这个lamdba的逻辑创建一个，
                            // 也就是说我的的createBean方法是真正创建bean实例的方法，这里我们之后会重点看
                            sharedInstance = getSingleton(beanName, () -> {
                                try {
                                    return createBean(beanName, mbd, args);
                                }
                                catch (BeansException ex) {
                                    destroySingleton(beanName);
                                    throw ex;
                                }
                            });
                            // 通过这个bean实例获取用户真正需要的bean实例
                            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                        }
                        else if (mbd.isPrototype()) {
                            // 如果是多例的bean
                            // 那么每次获取都是创建一个新的bean实例
                            Object prototypeInstance = null;
                            try {
                                beforePrototypeCreation(beanName);
                                // 可以看到这里直接去调用createBean了
                                prototypeInstance = createBean(beanName, mbd, args);
                            }
                            finally {
                                afterPrototypeCreation(beanName);
                            }
                            // 这里逻辑还是一样的
                            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                        }
                        else {
                            // spring是允许我们自定义scope的，这里是自定义scope的逻辑
                            // 需要注意的是，spring mvc 的 session、request那些scope也是走这里的逻辑的
                            // 这里感兴趣的同学可以自行看下，暂时不讲
                            String scopeName = mbd.getScope();
                            final Scope scope = this.scopes.get(scopeName);
                            if (scope == null) {
                                throw new IllegalStateException(...);
                            }
                            try {
                                Object scopedInstance = scope.get(beanName, () -> {
                                    beforePrototypeCreation(beanName);
                                    try {
                                        return createBean(beanName, mbd, args);
                                    }
                                    finally {
                                        afterPrototypeCreation(beanName);
                                    }
                                });
                                bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                            }
                            catch (IllegalStateException ex) {
                                throw new BeanCreationException(...);
                            }
                        }
                    }
                    catch (BeansException ex) {
                        cleanupAfterBeanCreationFailure(beanName);
                        throw ex;
                    }
                }

                // 这里是类型转换的逻辑，getBean是有可以传类型的重载方法的
                // 不过我们初始化的时候不会走到这个逻辑来，感兴趣的同学可以自行看
                if (requiredType != null && !requiredType.isInstance(bean)) {
                    try {
                        T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
                        if (convertedBean == null) {
                            throw new BeanNotOfRequiredTypeException(...);
                        }
                        return convertedBean;
                    }
                    catch (TypeMismatchException ex) {
                        throw new BeanNotOfRequiredTypeException(...);
                    }
                }
                // 返回获取到的bean
                return (T) bean;
            }

            我们继续看一下单例bean的创建逻辑，即：
            if (mbd.isSingleton()) {
                sharedInstance = getSingleton(beanName, () -> {
                    try {
                        return createBean(beanName, mbd, args);
                    }
                    catch (BeansException ex) {
                        // ...
                        destroySingleton(beanName);
                        throw ex;
                    }
                });
                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            }
            我们看一下这个getSingleton方法，需要注意的是，这个方法在DefaultSingletonBeanRegistry类中：
            /** Cache of singleton objects: bean name to bean instance. */
            private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
            /** Names of beans that are currently in creation. */
            private final Set<String> singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap<>(16));

            public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
                synchronized (this.singletonObjects) {
                    // 可以看到，我们先从singletonObjects通过beanName获取实例
            		// 这是不是说明singletonObjects就是spring用来存放所以单例bean的容器呢？可以说是的。
                    Object singletonObject = this.singletonObjects.get(beanName);
                    if (singletonObject == null) {
            			// 跳过了一个spring单例bean容器状态判断，
                        // 如果spring单例bean容器正在销毁时不允许继续创建单例bean的

                        // 创建容器之前的钩子，这里默认会把bean那么加入到一个正在创建的beanNameSet，
                        // 如果加入失败就代表是循环依赖了。
                        // 检测容器是  singletonsCurrentlyInCreation
                        beforeSingletonCreation(beanName);
                        boolean newSingleton = false;
                        boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
                        if (recordSuppressedExceptions) {
                            this.suppressedExceptions = new LinkedHashSet<>();
                        }
                        try {
                            // 这里就是调用传进来的lamdba了
                            // 也就是调用了createBean创建了bean实例
                            singletonObject = singletonFactory.getObject();
                            newSingleton = true;
                        }
                        catch (IllegalStateException ex) {
                            // Has the singleton object implicitly appeared in the meantime ->
                            // if yes, proceed with it since the exception indicates that state.
                            singletonObject = this.singletonObjects.get(beanName);
                            if (singletonObject == null) {
                                throw ex;
                            }
                        }
                        catch (BeanCreationException ex) {
                            if (recordSuppressedExceptions) {
                                for (Exception suppressedException : this.suppressedExceptions) {
                                    ex.addRelatedCause(suppressedException);
                                }
                            }
                            throw ex;
                        }
                        finally {
                            if (recordSuppressedExceptions) {
                                this.suppressedExceptions = null;
                            }
                            // 从正在创建的beanNameSet移除
                            afterSingletonCreation(beanName);
                        }
                        // 如果成功创建了bean实例，需要加入singletonObjects容器
                        // 这样下次再获取就能直接中容器中拿了
                        if (newSingleton) {
                            addSingleton(beanName, singletonObject);
                        }
                    }
                    return singletonObject;
                }
            }
            可以看到，这个getSingleton方法就是先从singletonObjects获取bean实例，获取不到就创建一个，其中还加了一些循环依赖的检测逻辑。
        3. createBean，真正的bean初始化逻辑
            我们说createBean方法是真正的bean初始化逻辑，但是这个初始化不仅仅是说创建一个实例就好了，
            还涉及到一些校验，以及类里的依赖注入、初始化方法调用等逻辑，我们现在就一起来简单看一下：
            protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
                throws BeanCreationException {

                RootBeanDefinition mbdToUse = mbd;
                // 获取bean的类型
                Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
                if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
                    mbdToUse = new RootBeanDefinition(mbd);
                    mbdToUse.setBeanClass(resolvedClass);
                }

                // Prepare method overrides.
                try {
                    // 这里对beanDefinition中的MethodOverrides做一些准备
                    // 主要是梳理一下所有重写方法（xml<replaced-method><lockup-method>标签对应的属性）
                    // 看下这些方法是否是真的有重载方法，没有重载的话会设置overloaded=false，
                    // 毕竟有些人配置的时候即使没有重载方法也会使用<replaced-method>标签
                    // (这功能我确实也没用过。。
                    mbdToUse.prepareMethodOverrides();
                }
                catch (BeanDefinitionValidationException ex) {
                    throw new BeanDefinitionStoreException(...);
                }

                try {
                    // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
                    // 给BeanPostProcessors一个机会，在我们的bean实例化之前返回一个代理对象，即完全不走spring的实例化逻辑
                    // 也是个BeanPostProcessors的钩子，就是循环beanPostProcessors然后调用的逻辑
                    Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
                    if (bean != null) {
                        return bean;
                    }
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(...);
                }

                try {
                    // 这里是spring真正bean实例化的地方了
                    Object beanInstance = doCreateBean(beanName, mbdToUse, args);
                    // 获取到了直接返回
                    return beanInstance;
                }
                // 跳过异常处理
            }

            3.0. doCreateBean是如何实例化一个bean的？
                刚刚有说到，doCreateBean是我们spring真正的实例化bean的逻辑，那我们一起来看一下：
                protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
                    throws BeanCreationException {

                    // Instantiate the bean.
                    BeanWrapper instanceWrapper = null;
                    if (mbd.isSingleton()) {
                        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
                    }
                    if (instanceWrapper == null) {
                        // 创建bean实例
                        instanceWrapper = createBeanInstance(beanName, mbd, args);
                    }
                    final Object bean = instanceWrapper.getWrappedInstance();
                    Class<?> beanType = instanceWrapper.getWrappedClass();
                    if (beanType != NullBean.class) {
                        mbd.resolvedTargetType = beanType;
                    }

                    synchronized (mbd.postProcessingLock) {
                        if (!mbd.postProcessed) {
                            try {
                                // 调用一个BeanPostProcessor的钩子方法,这里调用的是
                                // MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition
                                // 这个钩子方法是在bean实例创建之后，依赖注入之前调用的，需要注意的是
                                // @Autowired和@Value注解的信息收集-AutowiredAnnotationBeanPostProcessor
                                // @PostConstruct、@PreDestroy注解信息收集-CommonAnnotationBeanPostProcessor
                                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                            }
                            catch (Throwable ex) {
                                throw new BeanCreationException(...);
                            }
                            mbd.postProcessed = true;
                        }
                    }

                   	// 这一部分是使用3级缓存来解决循环依赖问题的，之后再看
                    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
                                                      isSingletonCurrentlyInCreation(beanName));
                    if (earlySingletonExposure) {
                        // 加入三级缓存
                        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
                    }


                    Object exposedObject = bean;
                    try {
                        // 依赖注入
                        populateBean(beanName, mbd, instanceWrapper);
                        // bean初始化-主要是调用一下初始化方法
                        exposedObject = initializeBean(beanName, exposedObject, mbd);
                    }
                    catch (Throwable ex) {
                        if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
                            throw (BeanCreationException) ex;
                        }
                        else {
                            throw new BeanCreationException(...);
                        }
                    }
                	// 这里也算是循环依赖检测的，暂时不讲
                    if (earlySingletonExposure) {
                        Object earlySingletonReference = getSingleton(beanName, false);
                        if (earlySingletonReference != null) {
                            if (exposedObject == bean) {
                                exposedObject = earlySingletonReference;
                            }
                            else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
                                String[] dependentBeans = getDependentBeans(beanName);
                                Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
                                for (String dependentBean : dependentBeans) {
                                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                                        actualDependentBeans.add(dependentBean);
                                    }
                                }
                                if (!actualDependentBeans.isEmpty()) {
                                    throw new BeanCurrentlyInCreationException(...);
                                }
                            }
                        }
                    }
                    try {
                        // 如果是单例bean，还会注册销毁事件
                        registerDisposableBeanIfNecessary(beanName, bean, mbd);
                    }
                    catch (BeanDefinitionValidationException ex) {
                        throw new BeanCreationException(...);
                    }

                    return exposedObject;
                }

                可以看到，我们的doCreateBean大致做了5件事：
                    1.创建bean实例
                    2.调用beanPostProcessor的埋点方法
                    3.注入当前类依赖的bean
                    4.调用当前bean的初始化方法
                    5.注册当前bean的销毁逻辑

            3.1. createBeanInstance创建bean实例
                大家平常是怎么实例化一个类呢？是直接使用构造器new出来一个？还是使用工厂方法获取？
                很显然，spring也是支持这两种方式的，如果同学们还记得bean标签的解析的话，
                那应该还会记得spring除了有提供使用构造器实例化bean的constructor-arg标签外，
                还提供了factory-bean和factory-method属性来配置使用工厂方法来实例化bean。

                并且之前在讲ConfigurationClassPostProcessor的时候，我们讲到@bean标签的时候，
                也有看到，对于@bean标签的处理，就是新建一个beanDefinition，并把当前的配置类和@Bean修饰的方法分别塞入了这个beanDefinition的factoryBeanName
                和factoryMethodName属性（可以空降ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod）。

                接下来我们就来看一下createBeanInstance的代码：
                protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
                    Class<?> beanClass = resolveBeanClass(mbd, beanName);
                	// 校验
                    if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                        "Bean class isn't public, and non-public access not allowed: " + beanClass.getName());
                    }
                	// 如果beanDefinition里有instanceSupplier，直接通过instanceSupplier拿就行了
                    // 这种情况我们就不重点讲了，其实跟工厂方法的方式也差不多
                    Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
                    if (instanceSupplier != null) {
                        return obtainFromSupplier(instanceSupplier, beanName);
                    }

                	// 如果工厂方法不为空，就使用工厂方法实例化
                    if (mbd.getFactoryMethodName() != null) {
                        return instantiateUsingFactoryMethod(beanName, mbd, args);
                    }

                    // 这里是对非单例bean做的优化，如果创建过一次了，
                    // spring会把相应的构造器或者工厂方法存到resolvedConstructorOrFactoryMethod字段
                    // 这样再次创建这个类的实例的时候就可以直接使用resolvedConstructorOrFactoryMethod创建了
                    boolean resolved = false;
                    boolean autowireNecessary = false;
                    if (args == null) {
                        synchronized (mbd.constructorArgumentLock) {
                            if (mbd.resolvedConstructorOrFactoryMethod != null) {
                                resolved = true;
                                autowireNecessary = mbd.constructorArgumentsResolved;
                            }
                        }
                    }
                    if (resolved) {
                        if (autowireNecessary) {
                            return autowireConstructor(beanName, mbd, null, null);
                        }
                        else {
                            return instantiateBean(beanName, mbd);
                        }
                    }

                    // 如果beanDefinition没有构造器信息，则通过beanPostProcessor选择一个
                    Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
                    // 1.如果通过beanPostProcessor找到了合适的构造器
                    // 2.或者autowireMode==AUTOWIRE_CONSTRUCTOR（这个xml配置的时候也可以指定的）
                    // 3.或者有配置构造器的参数（xml配置constructor-arg标签）
                    // 4.获取实例化bean是直接传进来了参数
                    // 只要符合上面四种情况之一，我们就会通过autowireConstructor方法来实例化这个bean
                    if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
                        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
                        // 需要构造器方式注入的bean的实例化
                        return autowireConstructor(beanName, mbd, ctors, args);
                    }

                    // 这里主要逻辑是兼容kotlin的，我们暂时不看
                    ctors = mbd.getPreferredConstructors();
                    if (ctors != null) {
                        // 需要构造器方式注入的bean的实例化
                        return autowireConstructor(beanName, mbd, ctors, null);
                    }

                    // 不需要特殊处理的话，就直接使用无参构造器了
                    return instantiateBean(beanName, mbd);
                }

                而拿到具体的参数之后，其实不管是构造器还是工厂方法实例化，都是很清晰的，直接反射调用就好了。
                instantiateBean就是获取无参构造器然后反射实例化的一个逻辑，逻辑比较简单，这边也不跟了。

                3.1.1. 通过determineConstructorsFromBeanPostProcessors方法选择构造器
                    这边主要带大家跟一下determineConstructorsFromBeanPostProcessors这个方法，
                    因为我们现在大部分都是使用注解来声明bean的，而如果大家在使用注解的时候也是使用构造器的方式注入的话，
                    那么是通过这个方法来拿到相应的构造器的。
                    protected Constructor<?>[] determineConstructorsFromBeanPostProcessors(@Nullable Class<?> beanClass, String beanName)
                        throws BeansException {
                        if (beanClass != null && hasInstantiationAwareBeanPostProcessors()) {
                            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
                                    Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
                                    if (ctors != null) {
                                        // 一旦拿到构造器就返回了
                                        return ctors;
                                    }
                                }
                            }
                        }
                        return null;
                    }

                    可以看到，还是通过beanPostProcessor的埋点来做的，这里是调用的SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors，
                    这里也不给大家卖关子了，我们真正支撑注解方式，选择构造器的逻辑在AutowiredAnnotationBeanPostProcessor中，有没有感觉这个类好像也有点熟悉？
                    public static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(
                    			BeanDefinitionRegistry registry, @Nullable Object source) {
                        // ...
                        if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
                            RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
                            def.setSource(source);
                            beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
                        }
                        // ...
                    }
                    也是有在调用AnnotationConfigUtils#registerAnnotationConfigProcessors方法的时候有注入哦~
                    从名称可以看到，这个beanPostProcessor是应该是用来处理@Autowired注解的，
                    有同学要说了，这不是属性注入的注解么，跟构造器有什么关系？那我们已一个构造器注入的bean来举例：
                    @Service
                    public class ConstructorAutowiredBean {
                        private Student student;
                        @Autowired
                        public ConstructorAutowiredBean(Student student) {
                            this.student = student;
                        }
                    }
                    大部分同学可能忘了，@Autowired是可以用来修饰构造器的，被@Autowired修饰的构造器的参数也将会中spring容器中获取。
                    不过，其实我们平常即使使用构造器注入也不打@Autowired注解也是没问题的，
                    这其实也是AutowiredAnnotationBeanPostProcessor获取构造器时的一个容错逻辑，我们一起看一下代码就知道了：
                    public Constructor<?>[] determineCandidateConstructors(Class<?> beanClass, final String beanName)
                        throws BeanCreationException {
                    	// 整个方法分为了两个部分
                        // 第一部分是收集这个类上被@Lookup修饰的方法
                        // 这个注解的功能和我们xml的lookup-method标签是一样的
                        // 而收集部分也是一样的封装到了一个MethodOverride并且加入到beanDefinition里面去了
                        // 虽然这部分工作（@Lookup注解的收集工作）是应该放在bean创建之前（有MethodOverride的话会直接生成代理实例）
                        // 但是放在当前这个determineCandidateConstructors方法里我还是觉得不太合适
                        // 毕竟跟方法名的语意不符，不过好像确实没有其它合适的钩子了，可能也只能放这了
                        if (!this.lookupMethodsChecked.contains(beanName)) {
                            if (AnnotationUtils.isCandidateClass(beanClass, Lookup.class)) {
                                try {
                                    Class<?> targetClass = beanClass;
                                    do {
                                        ReflectionUtils.doWithLocalMethods(targetClass, method -> {
                                            // 循环处理所有的方法，获取@Lookup注解并封装信息
                                            Lookup lookup = method.getAnnotation(Lookup.class);
                                            if (lookup != null) {
                                                LookupOverride override = new LookupOverride(method, lookup.value());
                                                try {
                                                    RootBeanDefinition mbd = (RootBeanDefinition)
                                                        this.beanFactory.getMergedBeanDefinition(beanName);
                                                    mbd.getMethodOverrides().addOverride(override);
                                                }
                                                catch (NoSuchBeanDefinitionException ex) {
                                                    throw new BeanCreationException(...);
                                                }
                                            }
                                        });
                                        targetClass = targetClass.getSuperclass();
                                    }
                                    while (targetClass != null && targetClass != Object.class);

                                }
                                catch (IllegalStateException ex) {
                                    throw new BeanCreationException(...);
                                }
                            }
                            this.lookupMethodsChecked.add(beanName);
                        }

                        // 这里开始是选择构造器的逻辑了
                        // 先从缓存拿...这些也是为非单例bean设计的，这样就不用每次进来都走选择构造器的逻辑了
                        Constructor<?>[] candidateConstructors = this.candidateConstructorsCache.get(beanClass);
                        if (candidateConstructors == null) {
                            synchronized (this.candidateConstructorsCache) {
                                candidateConstructors = this.candidateConstructorsCache.get(beanClass);
                                if (candidateConstructors == null) {
                                    Constructor<?>[] rawCandidates;
                                    try {
                                        // 获取当前类的所有的构造器
                                        rawCandidates = beanClass.getDeclaredConstructors();
                                    }
                                    catch (Throwable ex) {
                                        throw new BeanCreationException(...);
                                    }
                                    // 这个列表存符合条件的构造器
                                    List<Constructor<?>> candidates = new ArrayList<>(rawCandidates.length);
                                    Constructor<?> requiredConstructor = null;
                                    Constructor<?> defaultConstructor = null;
                                    // 这个primaryConstructor我们不管，是兼容kotlin的逻辑
                                    Constructor<?> primaryConstructor = BeanUtils.findPrimaryConstructor(beanClass);
                                    int nonSyntheticConstructors = 0;
                                    for (Constructor<?> candidate : rawCandidates) {
                                        // 循环每个构造器
                                        if (!candidate.isSynthetic()) {
                                            // 这个判断是判断不是合成的构造器，同学们想了解这个Synthetic可以自行查一下
                                            // 这边就不展开了，这个主意是和内部类有关，Synthetic的构造器是编译器自行生成的
                                            nonSyntheticConstructors++;
                                        }
                                        else if (primaryConstructor != null) {
                                            continue;
                                        }
                                        // 找一下构造器上有没有目标注解，说白了就是找@Autowired注解
                                        MergedAnnotation<?> ann = findAutowiredAnnotation(candidate);
                                        if (ann == null) {
                                           	// 如果找不到，这里认为可能是因为当前这个class是spring生成的cglib代理类
                                			// 所以这里尝试拿一下用户的class
                                            Class<?> userClass = ClassUtils.getUserClass(beanClass);
                                            // 如果用户的class和之前的beanClass不一致，说明之前那个class真的是代理类了
                                            if (userClass != beanClass) {
                                                try {
                                                    // 这个时候去userClass拿一下对应的构造器
                                                    Constructor<?> superCtor =
                                                        userClass.getDeclaredConstructor(candidate.getParameterTypes());
                                                    // 再在用户的构造器上找一下注解
                                                    ann = findAutowiredAnnotation(superCtor);
                                                }
                                                catch (NoSuchMethodException ex) {
                                                }
                                            }
                                        }
                                        if (ann != null) {
                                            // 这里是找到注解了
                                            if (requiredConstructor != null) {
                                                // 这个分支直接报错了，意思是之前已经如果有被@Autowired注解修饰了的构造器
                                                // 且注解中的Required属性为true的时候，
                                                // 就不允许再出现其他被@Autowired注解修饰的构造器了
                                                // 说明@Autowired(required=true)在构造器上的语言是必须使用这个构造器
                                                throw new BeanCreationException(...);
                                            }
                                            // 拿注解上的required属性
                                            boolean required = determineRequiredStatus(ann);
                                            if (required) {
                                                if (!candidates.isEmpty()) {
                                                    // 这里也是一样的，有required的构造器，就不预约有其他被
                                                    // @Autowired注解修饰的构造器了
                                                    throw new BeanCreationException(...);
                                                }
                                                // requiredConstructor只能有一个
                                                requiredConstructor = candidate;
                                            }
                                            // 符合条件的构造器加入列表-即有@Autowired的构造器
                                            candidates.add(candidate);
                                        }
                                        else if (candidate.getParameterCount() == 0) {
                                            // 如果构造器的参数为空，那就是默认构造器了
                                            defaultConstructor = candidate;
                                        }
                                    }

                                    if (!candidates.isEmpty()) {
                                        // 如果被@Autowired修饰的构造器不为空
                                        if (requiredConstructor == null) {
                                            // 如果没有requiredConstructor，就把默认构造器加入列表
                                            // 如果有requiredConstructor，实际上candidates中就只有一个构造器了
                                            if (defaultConstructor != null) {
                                                candidates.add(defaultConstructor);
                                            }
                                            else if (candidates.size() == 1 && logger.isInfoEnabled()) {
                                                logger.info(...);
                                            }
                                        }
                                        // 然后把candidates列表赋值给返回值
                                        candidateConstructors = candidates.toArray(new Constructor<?>[0]);
                                    }
                                    else if (rawCandidates.length == 1 && rawCandidates[0].getParameterCount() > 0) {
                                        // 如果当前类总共也只有一个构造器，并且这个构造器是需要参数的
                                        // 那就直接使用这个构造器了
                                        // 这就是为什么我们平常构造器注入不打@Autowired注解也可以的原因
                                        candidateConstructors = new Constructor<?>[] {rawCandidates[0]};
                                    }
                                    // 以下主要是处理primaryConstructor的，我们就不读了
                                    else if (nonSyntheticConstructors == 2 && primaryConstructor != null &&
                                             defaultConstructor != null && !primaryConstructor.equals(defaultConstructor)) {
                                        candidateConstructors = new Constructor<?>[] {primaryConstructor, defaultConstructor};
                                    }
                                    else if (nonSyntheticConstructors == 1 && primaryConstructor != null) {
                                        candidateConstructors = new Constructor<?>[] {primaryConstructor};
                                    }
                                    else {
                                        // 都不满足，就是空数组了
                                        candidateConstructors = new Constructor<?>[0];
                                    }
                                    // 处理完之后放入缓存
                                    this.candidateConstructorsCache.put(beanClass, candidateConstructors);
                                }
                            }
                        }
                        // 之所以上面解析的时候，没找到构造器也是使用空数组而不是null
                        // 就是为了从缓存拿的时候，能区分究竟是没处理过（null），还是处理了但是找不到匹配的（空数组）
                        // 避免缓存穿透
                        return (candidateConstructors.length > 0 ? candidateConstructors : null);
                    }
                    如果能找到合适的构造器的话，就可以直接通过反射实例化对象了~

                3.2. 通过beanPostProcessor埋点来收集注解信息
                    通过createBeanInstance创建完类的实例之后，注入属性之前，我们有一个beanPostProcessor的埋点方法的调用：

                    synchronized (mbd.postProcessingLock) {
                        if (!mbd.postProcessed) {
                            try {
                                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                            }
                            catch (Throwable ex) {
                                throw new BeanCreationException(...);
                            }
                            mbd.postProcessed = true;
                        }
                    }
                    protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName) {
                        for (BeanPostProcessor bp : getBeanPostProcessors()) {
                            if (bp instanceof MergedBeanDefinitionPostProcessor) {
                                MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
                                bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
                            }
                        }
                    }
                    由于这个埋点中有一部分对注解进行支撑的逻辑还挺重要的，所以这里单独拿出来讲一下。

                    3.2.1. CommonAnnotationBeanPostProcessor收集@PostConstruct、@PreDestroy、@Resource信息
                        CommonAnnotationBeanPostProcessor也是AnnotationConfigUtils#registerAnnotationConfigProcessors方法注入的，
                        这里我就不带大家再看了。由于CommonAnnotationBeanPostProcessor实现了MergedBeanDefinitionPostProcessor接口，所以在这个埋点中也会被调用到，我们来看一下这个逻辑：

                        public class CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor
                            implements InstantiationAwareBeanPostProcessor, BeanFactoryAware, Serializable{
                            // 构造器
                            public CommonAnnotationBeanPostProcessor() {
                        		setOrder(Ordered.LOWEST_PRECEDENCE - 3);
                                // 给两个关键字段设置了
                        		setInitAnnotationType(PostConstruct.class);
                        		setDestroyAnnotationType(PreDestroy.class);
                        		ignoreResourceType("javax.xml.ws.WebServiceContext");
                        	}

                            @Override
                            public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
                                // 这里调用了父类的方法，正真的收集`@PostConstruct`、`@PreDestroy`注解的逻辑是在这里做的
                                super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);
                                // 这里就是收集@Resource注解的信息啦
                                InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);
                                // 检查一下
                                metadata.checkConfigMembers(beanDefinition);
                            }
                        }

                        3.2.1.1. 生命周期注解@PostConstruct、@PreDestroy信息收集
                            我们先看一下父类收集生命周期注解的实现：
                            public class InitDestroyAnnotationBeanPostProcessor
                                implements DestructionAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor, PriorityOrdered, Serializable{
                                @Override
                                public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
                                    // 寻找生命周期元数据
                                    LifecycleMetadata metadata = findLifecycleMetadata(beanType);
                                    // 对收集到的声明周期方法做一下校验处理
                                    metadata.checkConfigMembers(beanDefinition);
                                }

                                private LifecycleMetadata findLifecycleMetadata(Class<?> clazz) {
                                    if (this.lifecycleMetadataCache == null) {
                                        // 没有开启缓存就直接拿构建生命周期元数据了
                                        return buildLifecycleMetadata(clazz);
                                    }
                                    // 有开启缓存的话，就先从缓存找，找不到再构建，然后丢回缓存
                                    LifecycleMetadata metadata = this.lifecycleMetadataCache.get(clazz);
                                    if (metadata == null) {
                                        synchronized (this.lifecycleMetadataCache) {
                                            metadata = this.lifecycleMetadataCache.get(clazz);
                                            if (metadata == null) {
                                                // 构建
                                                metadata = buildLifecycleMetadata(clazz);
                                                this.lifecycleMetadataCache.put(clazz, metadata);
                                            }
                                            return metadata;
                                        }
                                    }
                                    return metadata;
                                }

                                private LifecycleMetadata buildLifecycleMetadata(final Class<?> clazz) {
                                    // 简单判断类上是不是一定没有initAnnotationType和destroyAnnotationType这两个注解修饰的方法
                                    // 相当于快速失败
                                    // 需要注意的是，当前场景下，这两个注解实例化的时候已经初始化为PostConstruct和PreDestroy了
                                    if (!AnnotationUtils.isCandidateClass(clazz, Arrays.asList(this.initAnnotationType, this.destroyAnnotationType))) {
                                        return this.emptyLifecycleMetadata;
                                    }
                            		// 用来储存类上所有初始化/销毁方法的容器
                                    List<LifecycleElement> initMethods = new ArrayList<>();
                                    List<LifecycleElement> destroyMethods = new ArrayList<>();
                                    Class<?> targetClass = clazz;

                                    do {
                                        // 中间容器来储存当前类的初始化/销毁方法
                                        final List<LifecycleElement> currInitMethods = new ArrayList<>();
                                        final List<LifecycleElement> currDestroyMethods = new ArrayList<>();
                            			// 循环类上的每一个方法
                                        ReflectionUtils.doWithLocalMethods(targetClass, method -> {
                                            if (this.initAnnotationType != null && method.isAnnotationPresent(this.initAnnotationType)) {
                                                // 如果方法被@PostConstruct注解修饰，包装成一个LifecycleElement
                                                LifecycleElement element = new LifecycleElement(method);
                                                // 加入收集初始化方法的中间容器
                                                currInitMethods.add(element);
                                            }
                                            if (this.destroyAnnotationType != null && method.isAnnotationPresent(this.destroyAnnotationType)) {
                                                // 如果方法被@PreDestroy注解修饰，包装成一个LifecycleElement
                                                // 加入收集销毁方法的中间容器
                                                currDestroyMethods.add(new LifecycleElement(method));
                                            }
                                        });
                            			// 加入所有初始化/销毁方法的容器
                                        // 需要注意的是，在整个循环过程中，
                                        // 当前类的初始化方法都是加入初始化方法容器的头部
                                        // 当前类的销毁方法都是加入销毁方法容器的尾部
                                        // 所以可以推断，初始化方法调用的时候是从父类->子类调用
                                        // 而销毁方法从子类->父类调用。
                                        // 即 bean初始化->调用父类初始化方法->调用子类初始化方法->...->调用子类销毁方法->调用父类销毁方法->销毁bean
                                        initMethods.addAll(0, currInitMethods);
                                        destroyMethods.addAll(currDestroyMethods);
                                        // 获取父类，循环处理所有父类上的初始化/销毁方法
                                        targetClass = targetClass.getSuperclass();
                                    }
                                    while (targetClass != null && targetClass != Object.class);
                            		// 把当前类class对象+初始化方法列表+销毁方法列表封装成一个LifecycleMetadata对象
                                    return (initMethods.isEmpty() && destroyMethods.isEmpty() ? this.emptyLifecycleMetadata :
                                            new LifecycleMetadata(clazz, initMethods, destroyMethods));
                                }
                            }
                            看一下这个生命周期元数据LifecycleMetadata的结构：
                            private class LifecycleMetadata {
                                // 目标类
                                private final Class<?> targetClass;
                                // 目标类上收集到的初始化方法
                                private final Collection<LifecycleElement> initMethods;
                                // 目标类上收集到的销毁方法
                                private final Collection<LifecycleElement> destroyMethods;
                                // 检查、校验后的初始化方法
                                @Nullable
                                private volatile Set<LifecycleElement> checkedInitMethods;
                                // 检查、校验后的销毁方法
                                @Nullable
                                private volatile Set<LifecycleElement> checkedDestroyMethods;

                                public void checkConfigMembers(RootBeanDefinition beanDefinition) {
                                    // 这是那个检查、校验方法
                                    Set<LifecycleElement> checkedInitMethods = new LinkedHashSet<>(this.initMethods.size());
                                    for (LifecycleElement element : this.initMethods) {
                                        // 循环处理每个初始化方法
                                        String methodIdentifier = element.getIdentifier();
                                        // 判断是否是标记为外部处理的初始化方法，
                                        // 如果是外部处理的方法的话，其实spring是不会管理这些方法的
                                        if (!beanDefinition.isExternallyManagedInitMethod(methodIdentifier)) {
                                            // 这里把当前方法注册到这个externallyManagedDestroyMethods
                                            // 我猜想是方法签名相同的方法就不调用两次了
                                            // 比如可能父类的方法打了@PostConstruct,子类重写之后也在方法上打了@PostConstruct
                                            // 这两个方法都会被收集到initMethods，但是当然不应该调用多次
                                            beanDefinition.registerExternallyManagedInitMethod(methodIdentifier);
                                            // 加入了检查后的初始化方法列表，实际调用初始化方法时也是会调用这个列表
                                            checkedInitMethods.add(element);
                                        }
                                    }
                                    // 销毁方法的处理逻辑和初始化方法一样，我直接跳过了
                                    this.checkedInitMethods = checkedInitMethods;
                                    this.checkedDestroyMethods = checkedDestroyMethods;
                                }
                            }
                            到这里为止，其实我们CommonAnnotationBeanPostProcessor对生命周期注解的收集过程就完成了，
                            其实主要是通过父类的模本方法，把被@PostConstruct、@PreDestroy修饰的方法的信息封装到了LifecycleMetadata。
                            看完InitDestroyAnnotationBeanPostProcessor的逻辑之后，同学们会不会有实现一套自己的生命周期注解的冲动呢？
                            毕竟写一个类继承一下然后在自己的类构造器中set一下initAnnotationType、destroyAnnotationType就可以了！
                        3.2.1.2. 依赖注入注解@Resource信息收集
                            刚刚有说道我们的findResourceMetadata方法是用来收集@Resource注解信息的，我们现在来看一下这里的逻辑：
                            private InjectionMetadata findResourceMetadata(String beanName, final Class<?> clazz, @Nullable PropertyValues pvs) {
                                // 也是一个缓存逻辑
                                String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
                                InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
                                if (InjectionMetadata.needsRefresh(metadata, clazz)) {
                                    synchronized (this.injectionMetadataCache) {
                                        metadata = this.injectionMetadataCache.get(cacheKey);
                                        if (InjectionMetadata.needsRefresh(metadata, clazz)) {
                                            if (metadata != null) {
                                                metadata.clear(pvs);
                                            }
                                            // 构建逻辑
                                            metadata = buildResourceMetadata(clazz);
                                            this.injectionMetadataCache.put(cacheKey, metadata);
                                        }
                                    }
                                }
                                return metadata;
                            }

                            private InjectionMetadata buildResourceMetadata(final Class<?> clazz) {
                                // 这个方法除了收集@Resource注解之外，
                                // 其实还会收集@WebServiceRef和@EJB注解（如果你的项目有引入这些）
                                // 不过由于@WebServiceRef和@EJB我们现在基本也不用了（反正我没用过）
                                // 我这边就把相应的逻辑删除掉了，这样看也清晰点
                                // 而且这些收集逻辑也是一致的，最多只是说最后把注解信息封装到不同的子类型而已
                                // 快速失败检测
                                if (!AnnotationUtils.isCandidateClass(clazz, resourceAnnotationTypes)) {
                                    return InjectionMetadata.EMPTY;
                                }
                            	// 收集到注入元素
                                List<InjectionMetadata.InjectedElement> elements = new ArrayList<>();
                                Class<?> targetClass = clazz;

                                do {
                                    // 这里套路其实跟收集生命周期注解差不多了
                                    // 也是循环收集父类的
                                    final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();
                                    // 循环处理每个属性
                                    ReflectionUtils.doWithLocalFields(targetClass, field -> {
                                        if (...) {...} // 其他注解的处理
                                        else if (field.isAnnotationPresent(Resource.class)) {
                                            // 静态属性不允许注入，当然其实@Autowired和@Value也是不允许的，
                                            // 只是那边不会报错，只是忽略当前方法/属性而已
                                            if (Modifier.isStatic(field.getModifiers())) {
                                                throw new IllegalStateException(...);
                                            }
                                            if (!this.ignoredResourceTypes.contains(field.getType().getName())) {
                                                // 不是忽略的资源就加入容器
                                                // ejb那些就是封装成EjbRefElement
                                                currElements.add(new ResourceElement(field, field, null));
                                            }
                                        }
                                    });
                            		// 循环处理每个方法，比如@Resource修饰的set方法啦（当然没规定要叫setXxx）
                                    // 这里会循环当前类声明的方法和接口的默认（default）方法
                                    ReflectionUtils.doWithLocalMethods(targetClass, method -> {
                                        // 这里是处理桥接方法的逻辑，桥接方法是编译器自行生成的方法。
                                        // 主要跟泛型相关，这里也不多拓展了
                                        Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
                                        if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {
                                            return;
                                        }
                                        // 由于这个工具类的循环是会循环到接口的默认方法的
                                        // 这里这个判断是处理以下场景的：
                                        // 接口有一个default方法，而当前类重写了这个方法
                                        // 那如果子类重写的method循环的时候，这个if块能进去
                                        // 接下来接口的相同签名的默认method进来时，
                                        // ClassUtils.getMostSpecificMethod(method, clazz)会返回子类中重写的那个方法
                                        // 这是就和当前方法（接口方法）不一致，就不会再进if块收集一遍了
                                        if (method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
                                            if (...) {...} // 其他注解的处理
                                            else if (bridgedMethod.isAnnotationPresent(Resource.class)) {
                                                if (Modifier.isStatic(method.getModifiers())) {
                                                    throw new IllegalStateException(...);
                                                }
                                                Class<?>[] paramTypes = method.getParameterTypes();
                                                if (paramTypes.length != 1) {
                                                    // 原来@Resource方法注入只支持一个参数的方法（set方法）
                                                    // 这个限制估计是规范定的
                                                    // @Autowired没有这个限制
                                                    throw new IllegalStateException(...);
                                                }
                                                if (!this.ignoredResourceTypes.contains(paramTypes[0].getName())) {
                                                    // 封装了一个属性描述符，这个主要用来加载方法参数的，暂时不展开
                                                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
                                                    // 也封装成一个ResourceElement加入容器
                                                    currElements.add(new ResourceElement(method, bridgedMethod, pd));
                                                }
                                            }
                                        }
                                    });
                            		// 每次都放到列表的最前面，说明是优先会注入父类的
                                    elements.addAll(0, currElements);
                                    targetClass = targetClass.getSuperclass();
                                }
                                while (targetClass != null && targetClass != Object.class);
                            	// 把当前类的class和收集到的注入元素封装成一个注入元数据
                                return InjectionMetadata.forElements(elements, clazz);
                            }
                            可以看到，其实跟生命周期那一块差不多，也是收集注解信息然后封装，只是这个注入元素的收集要同时收集属性和（set）方法而已，我们还是照常瞄一下这个数据结构：
                            public class InjectionMetadata {
                                // 目标类--属性需要注入到哪个类
                                private final Class<?> targetClass;
                            	// 注入元素
                                private final Collection<InjectedElement> injectedElements;
                            	// 检查后的注入元素
                                @Nullable
                                private volatile Set<InjectedElement> checkedElements;
                            }

                            public abstract static class InjectedElement {
                            		// Member是Method和Field的父类
                            		protected final Member member;
                            		// 通过这个属性区分是field还是method
                            		protected final boolean isField;
                            		// 属性描述符，如果是method会通过这个描述符获取入参
                            		@Nullable
                            		protected final PropertyDescriptor pd;
                            		@Nullable
                            		protected volatile Boolean skip;
                            }
                            获取到InjectionMetadata之后的metadata.checkConfigMembers逻辑，和生命周期那一块是一模一样的，这边就不跟了。
                            那么到这里为止我们CommonAnnotationBeanPostProcessor类在bean实例创建之后的埋点的逻辑就分析完了。

                        3.2.2. AutowiredAnnotationBeanPostProcessor收集@Autowired、@Value信息
                        AutowiredAnnotationBeanPostProcessor这个类的注册时机已经讲过很多遍了，
                        也是AnnotationConfigUtils#registerAnnotationConfigProcessors方法注入的，
                        这边我们直接看一下它的postProcessMergedBeanDefinition方法是如何收集注解信息的：

                        public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter
                            implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware {
                            // 自动注入注解类型
                            private final Set<Class<? extends Annotation>> autowiredAnnotationTypes = new LinkedHashSet<>(4);

                            public AutowiredAnnotationBeanPostProcessor() {
                                // autowiredAnnotationTypes中放入@Autowired、@Value
                                this.autowiredAnnotationTypes.add(Autowired.class);
                                this.autowiredAnnotationTypes.add(Value.class);
                                try {
                                    this.autowiredAnnotationTypes.add((Class<? extends Annotation>)
                                                                      ClassUtils.forName("javax.inject.Inject", AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));
                                }
                                catch (ClassNotFoundException ex) {
                                    // JSR-330 API not available - simply skip.
                                }
                            }

                            @Override
                            public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
                                // 这里其实就很熟悉了，和@Resource的处理过程看起来就是一模一样的
                                InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null);
                                metadata.checkConfigMembers(beanDefinition);
                            }

                            private InjectionMetadata buildAutowiringMetadata(final Class<?> clazz) {
                                // 缓存逻辑我这边就不看了，都是一模一样的
                                // 这个，其实连收集逻辑都基本是一致的，我们就简单过一下吧
                                if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) {
                                    return InjectionMetadata.EMPTY;
                                }

                                List<InjectionMetadata.InjectedElement> elements = new ArrayList<>();
                                Class<?> targetClass = clazz;

                                do {
                                    final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();
                        			// 处理属性
                                    ReflectionUtils.doWithLocalFields(targetClass, field -> {
                                        MergedAnnotation<?> ann = findAutowiredAnnotation(field);
                                        if (ann != null) {
                                            // 静态属性不允许注入
                                            if (Modifier.isStatic(field.getModifiers())) {
                                                return;
                                            }
                                            // @Autowrired有一个required属性需要收集一下
                                            boolean required = determineRequiredStatus(ann);
                                            currElements.add(new AutowiredFieldElement(field, required));
                                        }
                                    });
                        			// 处理方法
                                    ReflectionUtils.doWithLocalMethods(targetClass, method -> {
                                        Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
                                        if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {
                                            return;
                                        }
                                        MergedAnnotation<?> ann = findAutowiredAnnotation(bridgedMethod);
                                        if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
                                            if (Modifier.isStatic(method.getModifiers())) {
                        						// 静态方法不处理，忽略，相当于不生效，@Resource那边是会报错的。
                                                return;
                                            }
                                            boolean required = determineRequiredStatus(ann);
                                            // 封装一个属性描述符描述符
                                            PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
                                            currElements.add(new AutowiredMethodElement(method, required, pd));
                                        }
                                    });
                        			// 父类优先
                                    elements.addAll(0, currElements);
                                    targetClass = targetClass.getSuperclass();
                                }
                                while (targetClass != null && targetClass != Object.class);
                        		// 封装到InjectionMetadata
                                return InjectionMetadata.forElements(elements, clazz);
                            }
                        }
                    3.2.3. 总结CommonAnnotationBeanPostProcessor和AutowiredAnnotationBeanPostProcessor
                        这个埋点基本上就这两个beanPostProcessor做了事情了，而且也与我们平常的开发息息相关，这边简单总结一下。

                        3.2.3.1 职能划分
                        这两个beanPostProcessor的职能上是有划分的：
                        1.CommonAnnotationBeanPostProcessor主要处理jdk相关的规范的注解，@Resource、@PostConstruct等注解都是jdk的规范中定义的。
                        收集生命周期相关的@PostConstruct、@PreDestroy注解信息封装成LifecycleMetadata
                        收集资源注入注解（我们主要关注@Resource）信息封装成InjectionMetadata

                        2.AutowiredAnnotationBeanPostProcessor主要处理spring定义的@Autowired相关的功能
                          这里不得不说一下我觉得这个类也用来处理javax.inject.Inject不合理
                          收集自动注入相关的注解@Autowired、@Value信息封装成InjectionMetadata

                       3.2.3.2 使用@Resouce还是@Autowired？

                       1.@Resouce和@Autowired都不能用来注入静态属性（通过在静态属性上使用注解和静态方法上使用注解）
                       2.使用@Resouce注入静态属性时，会直接抛出IllegalStateException导致当前实例初始化流程失败
                       3.而使用@Autowired注入静态属性时，只会忽略当前属性，不注入了，不会导致实例初始化流程失败
                       4.使用@Resouce修饰方法时，方法只能有一个入参，而@Autowired没有限制
                       5.@Resouce属于jdk的规范，可以认为对项目零入侵；@Autowired属于spring的规范，使用了@Autowired的话就不能替换成别的IOC框架了

四下.逐行解读Spring（四） - 万字长文讲透bean生命周期（下）
    三、bean实例化
        3. createBean，真正的bean初始化逻辑
        3.3. populateBean，对bean进行自动装配
        接下来我们继续回到bean实例化的主流程（不知道同学们会不会已经忘了看到哪了=.=），
        调用完beanPostProcessor的一个埋点之后，我们就进入自动装配的流程了，也就是这个：
        // 自动装配
        populateBean(beanName, mbd, instanceWrapper);
        // 执行初始化方法
        exposedObject = initializeBean(beanName, exposedObject, mbd);

        protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {

            // 这里又是一个埋点，放入三级缓存之后，自动装配之前
            if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
                for (BeanPostProcessor bp : getBeanPostProcessors()) {
                    if (bp instanceof InstantiationAwareBeanPostProcessor) {
                        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                        // 可以看到，这个埋点是bean实例和beanName传入了
                        // 所以我们可以在这个埋点做一下自定义的属性的注入（拿到实例了很好说嘛），
                        // 比如公共字段的set啦（反正我没在这里拓展过）
                        // 不过需要主要的是，如果这个埋点返回false的话，是认为不需要spring来进行自动装配了
                        // 会直接结束当前方法，跳过该bean的自动装配流程的
                        if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                            return;
                        }
                    }
                }
            }

            PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
            // 这里是通过resolvedAutowireMode，来通过不同的方式注入propertyValues中的属性了
            // 这个propertyValues就是我们xml标签解析中的property标签封装的对象啦
            // 当然我们后期也可以修改
            int resolvedAutowireMode = mbd.getResolvedAutowireMode();
            if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
                MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
                if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
                    // 通过名称注入，其实就是getBean(beanName)
                    autowireByName(beanName, mbd, bw, newPvs);
                }
                if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
                    // 这里逻辑稍微复杂点，不过简单说就是getBean(beanName, beanClass)而已
                    autowireByType(beanName, mbd, bw, newPvs);
                }
                pvs = newPvs;
            }
        	// 到这里为止就处理好了beanDefinition中封装的propertyValues依赖的信息

            boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
            boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);
            // 这里又是一个埋点啦
            PropertyDescriptor[] filteredPds = null;
            if (hasInstAwareBpps) {
                if (pvs == null) {
                    pvs = mbd.getPropertyValues();
                }

                // 这个埋点的时机是在把pvs的值注入到bean实例之前，给一个埋点，
                // 允许beanPostProcessor修改pvs和bean实例的信息
                // 所以之前创建bean实例之后的埋点收集的属性注入的信息
                // 这里就可以用这些信息，来修改pvs或者bean实例了
                for (BeanPostProcessor bp : getBeanPostProcessors()) {
                    if (bp instanceof InstantiationAwareBeanPostProcessor) {
                        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                        PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
                        // 如果通过新接口没做任何逻辑，则还是走旧接口试下
                        if (pvsToUse == null) {
                            if (filteredPds == null) {
                                filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                            }
                            // 这个接口在5.1版本基本已经废弃了，我们就不看了
                            pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
                            if (pvsToUse == null) {
                                return;
                            }
                        }
                        pvs = pvsToUse;
                    }
                }
            }
            // 依赖检查，不讲
            if (needsDepCheck) {
                if (filteredPds == null) {
                    filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                }
                checkDependencies(beanName, mbd, filteredPds, pvs);
            }

            if (pvs != null) {
                // 真正把pvs中的属性注入到bean实例里面去
                applyPropertyValues(beanName, mbd, bw, pvs);
            }
        }
        3.3.1. @Resource、@Autowired的注入逻辑
            xml方式配置的信息的注入我这边就不仔细讲了，主要现在这种方式也用的很少，
            并且对我们了解spring的逻辑没有太大的帮助，需要注意的是，beanDefinition的propertyValues中的属性的注入，
            是调用bean对象的对应set方法进行注入的，如果该属性没有set方法，注入会报错并且导致spring启动失败。

            解下来我们稍微讲一下基于注解的属性注入方式。因为@Resource和@Autowired注解的信息最后都封装成了InjectionMetadata，
            那么他们的注入的逻辑应该也是差别不大的，我们可以看一下：

            // CommonAnnotationBeanPostProcessor
            @Override
            public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
                // 这一次肯定能从缓存中拿到了，之前已经构建了
                InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);
                try {
                    // 注入
                    metadata.inject(bean, beanName, pvs);
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(beanName, "Injection of resource dependencies failed", ex);
                }
                return pvs;
            }
            // AutowiredAnnotationBeanPostProcessor
            @Override
            public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
                InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
                try {
                    metadata.inject(bean, beanName, pvs);
                }
                catch (BeanCreationException ex) {
                    throw ex;
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(beanName, "Injection of autowired dependencies failed", ex);
                }
                return pvs;
            }
            逻辑确实是一样的，都是委托给InjectionMetadata来注入：
            public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
                Collection<InjectedElement> checkedElements = this.checkedElements;
                Collection<InjectedElement> elementsToIterate =
                    (checkedElements != null ? checkedElements : this.injectedElements);
                if (!elementsToIterate.isEmpty()) {
                    for (InjectedElement element : elementsToIterate) {
                        // 接下来委托给具体的注入元素来操作
                        // 这里往下就有点不一样了
                        element.inject(target, beanName, pvs);
                    }
                }
            }
            我们接下来简单讲一下@Resource的注入逻辑，由于ResourceElement没有重写inject方法，所以它走的还是父类InjectedElement的逻辑：
            protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)
                throws Throwable {
                // 可以看到，就是通过isField判断是属性还是方法
                // 然后直接通过反射把属性设置或者调用方法了
                if (this.isField) {
                    Field field = (Field) this.member;
                    ReflectionUtils.makeAccessible(field);
                    // 通过这个getResourceToInject来获取了需要注入的资源
                    field.set(target, getResourceToInject(target, requestingBeanName));
                }
                else {
                    if (checkPropertySkipping(pvs)) {
                        return;
                    }
                    try {
                        Method method = (Method) this.member;
                        ReflectionUtils.makeAccessible(method);
                        method.invoke(target, getResourceToInject(target, requestingBeanName));
                    }
                    catch (InvocationTargetException ex) {
                        throw ex.getTargetException();
                    }
                }
            }
            我们来看一下这个模板方法inject中留给子类实现的getResourceToInject方法在ResourceElement中的实现：
            @Override
            protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {
                // 懒加载的逻辑我们就暂时不看了
                // 解释一下，无非就是把需要注入的类代理一层，暂时不使用getBean获取需要注入的类的实例
                // 当我们通过这个懒加载的属性去做任何动作时，代理层就会先根据这个属性的信息，去从beanFactory.getBean
                return (this.lazyLookup ? buildLazyResourceProxy(this, requestingBeanName) :
                        getResource(this, requestingBeanName));
            }

            protected Object getResource(LookupElement element, @Nullable String requestingBeanName)
                throws NoSuchBeanDefinitionException {
                // ...
                return autowireResource(this.resourceFactory, element, requestingBeanName);
            }
            protected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName)
                throws NoSuchBeanDefinitionException {
                Object resource;
                Set<String> autowiredBeanNames;
                String name = element.name;

                if (factory instanceof AutowireCapableBeanFactory) {
                    AutowireCapableBeanFactory beanFactory = (AutowireCapableBeanFactory) factory;
                    DependencyDescriptor descriptor = element.getDependencyDescriptor();
                    if (this.fallbackToDefaultTypeMatch && element.isDefaultName && !factory.containsBean(name)) {
                        autowiredBeanNames = new LinkedHashSet<>();
                        // 通过beanFactory获取依赖的bean实例
                        resource = beanFactory.resolveDependency(descriptor, requestingBeanName, autowiredBeanNames, null);
                        if (resource == null) {
                            throw new NoSuchBeanDefinitionException(element.getLookupType(), "No resolvable resource object");
                        }
                    }
                    else {
                        // 通过beanName获取依赖的bean实例
                        resource = beanFactory.resolveBeanByName(name, descriptor);
                        autowiredBeanNames = Collections.singleton(name);
                    }
                }
                else {
                    // 通过beanFactory获取bean
                    resource = factory.getBean(name, element.lookupType);
                    autowiredBeanNames = Collections.singleton(name);
                }

                // 注册bean的依赖信息
                if (factory instanceof ConfigurableBeanFactory) {
                    ConfigurableBeanFactory beanFactory = (ConfigurableBeanFactory) factory;
                    for (String autowiredBeanName : autowiredBeanNames) {
                        if (requestingBeanName != null && beanFactory.containsBean(autowiredBeanName)) {
                            beanFactory.registerDependentBean(autowiredBeanName, requestingBeanName);
                        }
                    }
                }
                return resource;
            }

            这一块通过beanFactory来加载bean的逻辑就暂时不深入了，里面逻辑比较绕，之后如果有机会，我再单独开博客讲。
            但是我们要知道，这个逻辑不管它怎么绕，它最终无非还是要通过beanFactory.getBean来获取依赖的bean的嘛，
            我都拿到这个注入元素的信息了，拿到这个需要注入的Field或者Method了，
            我难到还不知道我需要注入的bean是什么类型么？拿到类型我们肯定就能从beanFactory获取到实例啦。

        3.4. initializeBean调用bean的初始化方法
            不知道同学们日常开发时，有没有使用过XxxAware接口来获取一些spring的组件，
            或者是使用@PostConstruct注解/实现InitializingBean接口来做一些bean的初始化逻辑呢？initializeBean方法就是处理这些逻辑的地方。
            一个bean并不是说实例创建好，做完依赖注入之后，就可以交给用户使用了。spring还需要对这个bean做一些初始化工作。
            // 自动装配
            populateBean(beanName, mbd, instanceWrapper);
            // 执行初始化方法
            exposedObject = initializeBean(beanName, exposedObject, mbd);

            接下来，我们就一起看一下这个initializeBean的逻辑：
            protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
                // 调用aware方法 -- 需要注意的是这里只调用了一部分aware接口的方法
                // 还有一部分XxxAware接口的调用是通过beanPostProcessor来实现的
                invokeAwareMethods(beanName, bean);

                Object wrappedBean = bean;
                if (mbd == null || !mbd.isSynthetic()) {
                    // bean实例初始化之前的埋点
                    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
                }

                try {
                    // 调用初始化方法
                    invokeInitMethods(beanName, wrappedBean, mbd);
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(
                        (mbd != null ? mbd.getResourceDescription() : null),
                        beanName, "Invocation of init method failed", ex);
                }
                if (mbd == null || !mbd.isSynthetic()) {
                    // bean实例初始化之后的埋点
                    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
                }

                return wrappedBean;
            }
        3.4.1. invokeAwareMethods调用aware接口
            spring提供了一个标记接口Aware，用来给用户标记当前bean是需要获取某些spring能提供的组件/信息的：
            public interface Aware {
            	// 这是一个空的标记接口
            }
            而具体用户的bean需要spring提供什么组件/信息，则可以选择性的实现Aware的某个子接口。
            例如，如果我们的某个bean中需要拿到实例化它的beanFactory，那么我们可以实现BeanFactoryAware接口：
            public interface BeanFactoryAware extends Aware {
            	// bean中实现这接口就可以了，我们可以把beanFactory的引用保存下来
            	void setBeanFactory(BeanFactory beanFactory) throws BeansException;
            }
            那么对于这一些Aware接口的调用，spring是怎么做的呢？其实这也分为了两部分，一部分就是我们现在讲到的invokeAwareMethods方法：
            private void invokeAwareMethods(final String beanName, final Object bean) {
                if (bean instanceof Aware) {
                    // 判断->强转->调用一目了然，就不多说了
                    if (bean instanceof BeanNameAware) {
                        ((BeanNameAware) bean).setBeanName(beanName);
                    }
                    if (bean instanceof BeanClassLoaderAware) {
                        ClassLoader bcl = getBeanClassLoader();
                        if (bcl != null) {
                            ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
                        }
                    }
                    if (bean instanceof BeanFactoryAware) {
                        ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
                    }
                }
            }
            就是这样简单的判断->强转->调用就可以了，但是有同学可能会说了，
            这里才处理了三种Aware接口的情况，平常我用的ApplicationContextAware那些的处理逻辑怎么没有？
            其实这里也可以算是spring早期给自己挖的坑了，invokeAwareMethods这个方法是在bean初始化的主流程里的，
            属于很基础的代码。可是随着spring的慢慢开发，可能会有各类开发人员开始给spring团队提需求，
            希望新增一个XxxAware接口。这个时候spring团队一看，有些Aware接口确实可以由spring管理起来，
            这难道继续在这个invokeAwareMethods方法里加if-else么？显然是不行的，这违反了开闭原则！
            同学们，如果是你，面对这种新增XxxAware的需求，你会怎么处理呢？

        3.4.2. postProcessBeforeInitialization埋点调用
            invokeAwareMethods方法之后，我们马上有一个埋点的调用：
            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);

            public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
                throws BeansException {
                Object result = existingBean;
                for (BeanPostProcessor processor : getBeanPostProcessors()) {
                    // 调用BeanPostProcessor.postProcessBeforeInitialization
                    Object current = processor.postProcessBeforeInitialization(result, beanName);
                    if (current == null) {
                        return result;
                    }
                    result = current;
                }
                return result;
            }
            说起来才发现这个postProcessBeforeInitialization居然是BeanPostProcessor接口的方法
            ，而BeanPostProcessor的声明的两个方法其实就是这个initializeBean方法中的两个埋点。
            那是不是说明其实第一版的spring是只有这两个埋点的，随着框架的发展，
            才慢慢新增其他的继承BeanPostProcessor接口的埋点接口并且在bean初始化流程中被调用的呢？
            说回这个postProcessBeforeInitialization方法，这里也简单讲几个与我们平常使用相关的例子。
        3.4.2.1. 使用ApplicationContextAwareProcessor处理XxxAware接口需求
            刚刚讲invokeAwareMethods方法的时候有提过，对于日益增多的XxxAware接口需求，spring应该怎么做才会更优雅一点，符合开闭原则呢？
            spring的答案是，使用postProcessBeforeInitialization这个埋点方法，所以有了ApplicationContextAwareProcessor，我们直接来看下它的埋点方法：
            public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
                // 判断是否是需要处理的Aware接口
                if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
                      bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
                      bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)){
                    return bean;
                }
                invokeAwareInterfaces(bean);
                return bean;
            }

            private void invokeAwareInterfaces(Object bean) {
                if (bean instanceof EnvironmentAware) {
                    ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
                }
                if (bean instanceof EmbeddedValueResolverAware) {
                    ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
                }
                // ...跳过了其他XxxAware接口的处理逻辑，都是一样的
            }
            可以看到，逻辑还是挺简单的，差不多就是把invokeAwareMethods中的模式搬过来了。
        3.4.2.2. InitDestroyAnnotationBeanPostProcessor生命周期方法的调用
            如果同学们不至于太健忘的话，应该还记得我们刚刚有讲过一个CommonAnnotationBeanPostProcessor，
            它会在bean创建之后，依赖注入之前，调用postProcessMergedBeanDefinition这个埋点方法收集
            @PostConstruct、@PreDestroy注解的信息，而这个beanPostProcessor是继承自InitDestroyAnnotationBeanPostProcessor的，
            InitDestroyAnnotationBeanPostProcessor的两个埋点方法中就分别调用了收集到的生命周期方法：
            public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
                LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());
                try {
                    metadata.invokeInitMethods(bean, beanName);
                } catch (Throwable ex) {
                    throw new BeanCreationException(...);
                }
                return bean;
            }

            获取LifecycleMetadata的流程就不再讲了，这里肯定是直接从缓存拿到了，我们来看一下invokeInitMethods方法：
            public void invokeInitMethods(Object target, String beanName) throws Throwable {
                Collection<LifecycleElement> checkedInitMethods = this.checkedInitMethods;
                Collection<LifecycleElement> initMethodsToIterate =
                    (checkedInitMethods != null ? checkedInitMethods : this.initMethods);
                if (!initMethodsToIterate.isEmpty()) {
                    for (LifecycleElement element : initMethodsToIterate) {
                        // 调用方法
                        element.invoke(target);
                    }
                }
            }

            public void invoke(Object target) throws Throwable {
                // 直接就是反射调用了
                ReflectionUtils.makeAccessible(this.method);
                this.method.invoke(target, (Object[]) null);
            }
            所以从我们现在的角度来看，初始化方法中，通过@PostConstruct注解来声明的方法会最先被调用。

        3.4.3. invokeInitMethods调用初始化方法
            接下来就是初始化方法的调用了，这里主要需要处理两种方法的调用：
            1.实现了InitializingBean接口的bean，需要调用InitializingBean#afterPropertiesSet
            2.beanDefinition中有initMethodName属性的（比如通过xml解析加载来的）
            我们来看一下逻辑：
            protected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)
                throws Throwable {

                boolean isInitializingBean = (bean instanceof InitializingBean);
                if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
                    // 调用InitializingBean.afterPropertiesSet
                    ((InitializingBean) bean).afterPropertiesSet();
                }

                if (mbd != null && bean.getClass() != NullBean.class) {
                    String initMethodName = mbd.getInitMethodName();
                    if (StringUtils.hasLength(initMethodName) &&
                        !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
                        !mbd.isExternallyManagedInitMethod(initMethodName)) {
                        // 调用beanDefinition中的initMethod
                        // 就是个反射调用，我们就不再看了
                        invokeCustomInitMethod(beanName, bean, mbd);
                    }
                }
            }
            稍微说一下这个isExternallyManagedInitMethod判断的作用吧，
            这个判断主要是避免一个方法被调用两次的。在我们的beanDefinition中有一个
            Set<String> externallyManagedInitMethods用来记录哪些方法是不需要再调用了（销毁方法同理），
            而生命周期注解收集的时候，会把收集到的初始化方法的方法名塞进去，这样到这里invokeInitMethods的逻辑中，
            如果是被@PostConstruct注解收集并且调用过的方法，这里是不会再被调用的。

        3.4.4. postProcessAfterInitialization埋点调用
            初始化方法调用完后，又有一个埋点方法，这是这个bean创建好后，
            返回到用户手中之前的最后一个埋点了，这个时候bean中的所有信息都是齐全的。
            同学们可以想一想，我们可以在这个埋点做什么工作呢？
            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);

            public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
                throws BeansException {

                Object result = existingBean;
                for (BeanPostProcessor processor : getBeanPostProcessors()) {
                    // 初始化之后的埋点
                    Object current = processor.postProcessAfterInitialization(result, beanName);
                    if (current == null) {
                        return result;
                    }
                    result = current;
                }
                return result;
            }

            我们著名的aop的代理类创建的逻辑，就是在这个埋点做的。具体的入口类是AbstractAutoProxyCreator：
            public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
                if (bean != null) {
                    Object cacheKey = getCacheKey(bean.getClass(), beanName);
                    if (this.earlyProxyReferences.remove(cacheKey) != bean) {
                        // 如果需要的话，返回一个代理类
                        return wrapIfNecessary(bean, beanName, cacheKey);
                    }
                }
                return bean;
            }

        3.4.5. registerDisposableBeanIfNecessary注册bean的销毁逻辑
            整个bean初始化完成之后，我们还需要做最后一步，那就是注册bean的销毁逻辑：
            registerDisposableBeanIfNecessary(beanName, bean, mbd);
            protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
                // 如果是非prototype且需要销毁的bean
                if (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {
                    // 如果是单例的
                    if (mbd.isSingleton()) {
                        // 直接包装成DisposableBeanAdapter且DefaultSingletonBeanRegistry
                        // DefaultSingletonBeanRegistry#registerDisposableBean
                        registerDisposableBean(beanName,
                                               new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
                    }
                    else {
                        // 如果是自定义的scope
                        Scope scope = this.scopes.get(mbd.getScope());
                        if (scope == null) {
                            throw new IllegalStateException(...);
                        }
                        // 像scope注册
                        scope.registerDestructionCallback(beanName,
                                                          new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
                    }
                }
            }
            我们先看下requiresDestruction的逻辑：
            protected boolean requiresDestruction(Object bean, RootBeanDefinition mbd) {
                return (bean.getClass() != NullBean.class &&
                        (DisposableBeanAdapter.hasDestroyMethod(bean, mbd)
                        || (hasDestructionAwareBeanPostProcessors()
                        && DisposableBeanAdapter.hasApplicableProcessors(bean, getBeanPostProcessors()))));
            }
            逐一看一下DisposableBeanAdapter中的这两个方法：
            public static boolean hasDestroyMethod(Object bean, RootBeanDefinition beanDefinition) {
                // 如果实现了DisposableBean接口或者AutoCloseable接口
                // 认为有销毁方法
                if (bean instanceof DisposableBean || bean instanceof AutoCloseable) {
                    return true;
                }
                // 获取beanDefinition中的destoryMethodName属性
                String destroyMethodName = beanDefinition.getDestroyMethodName();
                if (AbstractBeanDefinition.INFER_METHOD.equals(destroyMethodName)) {
                    // 如果是一个特殊值-(inferred)，就看这个类有没有close或者shutdown方法
                    return (ClassUtils.hasMethod(bean.getClass(), CLOSE_METHOD_NAME) ||
                            ClassUtils.hasMethod(bean.getClass(), SHUTDOWN_METHOD_NAME));
                }
                // 看下有没有配置
                return StringUtils.hasLength(destroyMethodName);
            }
            // 如果容器中有注册DestructionAwareBeanPostProcessor，则还会有以下这个方法的判断
            public static boolean hasApplicableProcessors(Object bean, List<BeanPostProcessor> postProcessors) {
                if (!CollectionUtils.isEmpty(postProcessors)) {
                    for (BeanPostProcessor processor : postProcessors) {
                        if (processor instanceof DestructionAwareBeanPostProcessor) {
                            DestructionAwareBeanPostProcessor dabpp = (DestructionAwareBeanPostProcessor) processor;
                            if (dabpp.requiresDestruction(bean)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            简单说一下，InitDestroyAnnotationBeanPostProcessor实现了DestructionAwareBeanPostProcessor，
            大家应该知道这个requiresDestruction的逻辑大概是怎么样了吧？
            @Override
            public boolean requiresDestruction(Object bean) {
                // 就看有没有收集到销毁方法就好了
                return findLifecycleMetadata(bean.getClass()).hasDestroyMethods();
            }

            确定是一个需要销毁的单例bean之后，spring会把它包装成一个DisposableBean并且注册到DefaultSingletonBeanRegistry：
            public void registerDisposableBean(String beanName, DisposableBean bean) {
                synchronized (this.disposableBeans) {
                    // 可以看到是一个map而已
                    this.disposableBeans.put(beanName, bean);
                }
            }
        3.5. doCreateBean小结
            doCreateBean的逻辑我们讲完了，总体来讲，doCreateBean方法创建了一个可以直接使用的bean并返回给了调用方。回顾一下，它主要做了以下几件事：
            1.创建bean实例，可能是通过工厂方法或者构造器，且参数都支持依赖注入。
            2.依赖注入，解决@Resource、@Autowired等注解注入以及beanDefinition的propertyValues属性注入问题。
            3.初始化逻辑
                1.XxxAware接口调用
                2.初始化方法调用，初始化注解(@PostConstruct)->初始化接口(InitializingBean)->beanDefinition的initMethodName属性（例如xml配置）
            4.注册单例bean的销毁逻辑

        四、bean的销毁
            刚刚我们有看到，实例化bean时，我们会注册一个销毁逻辑到对应的scope，
            而对于单例bean来讲，其实可以说单例的scope就是由spring提供的，
            这个时候我们是把需要销毁的bean包装成了一个DisposableBeanAdapter并注册到了DefaultSingletonBeanRegistry的disposableBeans容器中。
            那么我们具体又是如何触发销毁方法的呢？我们随意找一个常用的ApplicationContext往上追踪，
            会发现它实现了ConfigurableApplicationContext接口，而这个接口中定义了销毁的close方法（refresh方法也是这个接口定义的）。
            我们找一个实现跟一下，会发现最终调用到了DefaultSingletonBeanRegistry#destroySingletons方法：
            public void AbstractApplicationContext#close() {
                // ...
                doClose();
                // ...
            }
            public void AbstractApplicationContext#doClose() {
                // ...
                destroyBeans();
                // ...
            }
            protected void AbstractApplicationContext#destroyBeans() {
                getBeanFactory().destroySingletons();
            }
            public void DefaultSingletonBeanRegistry#destroySingletons() {
                String[] disposableBeanNames;
                // 我们注册的disposableBeans
                synchronized (this.disposableBeans) {
                    disposableBeanNames = StringUtils.toStringArray(this.disposableBeans.keySet());
                }
                for (int i = disposableBeanNames.length - 1; i >= 0; i--) {
                    // 按注册的倒序销毁。主要是避免bean之间资源依赖，
                    // 先创建的bean肯定不会依赖后创建的bean的资源，所以先创建的bean先销毁
                    destroySingleton(disposableBeanNames[i]);
                }
            }
            public void DefaultSingletonBeanRegistry#destroySingleton(String beanName) {
                // 从IOC容器删除
                removeSingleton(beanName);

                // 从disposableBeans删除
                DisposableBean disposableBean;
                synchronized (this.disposableBeans) {
                    disposableBean = (DisposableBean) this.disposableBeans.remove(beanName);
                }
                // 调用销毁方法
                destroyBean(beanName, disposableBean);
            }
            我们来看简单一下这个销毁方法：
            protected void destroyBean(String beanName, @Nullable DisposableBean bean) {
                // 先把它依赖的bean销毁
                Set<String> dependencies;
                synchronized (this.dependentBeanMap) {
                    dependencies = this.dependentBeanMap.remove(beanName);
                }
                if (dependencies != null) {
                    for (String dependentBeanName : dependencies) {
                        destroySingleton(dependentBeanName);
                    }
                }

                if (bean != null) {
                    try {
                        // 执行当前bean的销毁逻辑
                        bean.destroy();
                    }
                    catch (Throwable ex) {
                    }
                }
            	// 跳过
            }
            依稀记得，我们之前注册进disposableBeans的，是包装成了一个DisposableBeanAdapter实例，那么我们来看一下它的destroy方法：
            public void destroy() {
                if (!CollectionUtils.isEmpty(this.beanPostProcessors)) {
                    for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) {
                        // 这里明显就是去调用InitDestroyAnnotationBeanPostProcessor的逻辑了
                        // 就不再跟了，跟初始化方法调用时一个套路
                        processor.postProcessBeforeDestruction(this.bean, this.beanName);
                    }
                }

                if (this.invokeDisposableBean) {
                    try {
                        // 调用实现了DisposableBean接口的bean的销毁方法
                        ((DisposableBean) this.bean).destroy();
                    }
                    catch (Throwable ex) {
                    }
                }
            	// 调用beanDefinition中配置的销毁方法
                if (this.destroyMethod != null) {
                    invokeCustomDestroyMethod(this.destroyMethod);
                }
                else if (this.destroyMethodName != null) {
                    Method methodToInvoke = determineDestroyMethod(this.destroyMethodName);
                    if (methodToInvoke != null) {
                        invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));
                    }
                }
            }

            这个逻辑就很清晰了，而且调用顺序和初始化方法的调用顺序是一样的。
            具体DisposableBeanAdapter中的这些属性的值是哪来的，感兴趣的同学可以跟一下这个类的构造方法，也是蛮清晰的，这边就不跟了。

        五、总结
            对于bean的生命周期，我们可以分为两个阶段：
            1.初始化阶段：创建bean实例->注入bean依赖->执行bean的初始化方法（注解->接口->beanDefinition配置）
            2.销毁阶段：销毁当前bean依赖的bean->将当前bean从IOC容器移除->调用当前bean的销毁方法（注解->接口->beanDefinition配置）

            我们现在按照bean的scope属性，来对bean的生命周期进行一个归纳总结：
            1.对于单例（singleton）的bean，spring管理其全生命周期，包括初始化阶段和销毁阶段。
            2.对应多例（prototype）的bean，spring只管理它的初始化阶段；销毁阶段有用户代码处理。
            3.其他自定义scope，spring管理其初始化阶段，并向调用scope#registerDestructionCallback注册bean的销毁逻辑，但销毁阶段的具体执行由该scope定义。

五。逐行解读Spring（五）- 没人比我更懂循环依赖！
https://juejin.cn/post/6860785780307492871
    一、前言

    二、什么是循环依赖
        首先我们需要明确，什么是循环依赖呢？这里举一个简单的例子：
        @Service
        public class A {
            @Autowired
            private B b;
        }
        @Service
        public class B {
            @Autowired
            private A a;
        }
        以这个例子来看，我们声明了a、b两个bean，且a中需要注入一个b，b中需要注入一个a。
        https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cca13f89a5a46e6872f7670d9b32524~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp

    三、三级缓存设计
        1. 自己解决循环依赖问题
            现在，假如我们是spring的架构师，我们应该怎么解决这个循环依赖问题呢？
        1.1. 流程设计
            首先如果要解决这个问题，我们的目标应该是要把之前的级联的无限创建流程切到，也就是说我们的流程要变为如下所示：
            https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec44ec153d5347a7ae8470b4e038cf04~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp

            也就是说，我们需要在B实例创建后，注入A的时候，能够拿到A的实例，这样才能打破无限创建实例的情况。
            而B实例的初始化流程，是在A实例创建之后，在populateBean方法中进行依赖注入时触发的。
            那么如果我们B实例化过程中，想要拿到A的实例，那么A实例必须在createBeanInstance创建实例后（实例都没有就啥也别说了）、
            populateBean方法调用之前，就暴露出去，让B能通过getBean获取到！
            （同学们认真想一下这个流程，在现有的流程下改造，是不是只能够这样操作？自己先想清楚这个流程，再去结合spring源码验证，这一块的知识点你以后想忘都忘不掉）
            https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0838fe3d2c174094b19aa40e6493b22b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp

        1.2. 伪代码实现
            // 正真已经初始化完成的map
            private Map<String, Object> singleMap = new ConcurrentHashMap<>(16);
            // 缓存的map
            private Map<String, Object> cacheMap = new ConcurrentHashMap<>(16);

            protected Object getBean(final String beanName) {
                // 先看一下目标bean是否完全初始化完了，完全初始化完直接返回
                Object single = singleMap.get(beanName);
                if (single != null) {
                    return single;
                }
                // 再看一下目标bean实例是否已经创建，已经创建直接返回
                single = cacheMap.get(beanName);
                if (single != null) {
                    return single;
                }
                // 创建实例
                Object beanInstance = createBeanInstance(beanName);
                // 实例创建之后，放入缓存
                // 因为已经创建实例了，这个时候这个实例的引用暴露出去已经没问题了
            	// 之后的属性注入等逻辑还是在这个实例上做的
                cacheMap.put(beanName, beanInstance);
                // 依赖注入，会触发依赖的bean的getBean方法
                populateBean(beanName, beanInstance);
                // 初始化方法调用
                initializeBean(beanName, beanInstance);
                // 从缓存移除，放入实例map
                singleMap.put(beanName, beanInstance);
                cacheMap.remove(beanName)

                return beanInstance;
            }

        2. Spring源码

        2.1. Spring的三级缓存设计

        2.1.1. 三级缓存源码

        首先，在我们的AbstractBeanFactory#doGetBean的逻辑中：

        // 初始化是通过getBean触发bean创建的，依赖注入最终也会使用getBean获取依赖的bean的实例
        public Object getBean(String name) throws BeansException {
            return doGetBean(name, null, null, false);
        }
        protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
                                  @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

            final String beanName = transformedBeanName(name);
            Object bean;

            // 获取bean实例
            Object sharedInstance = getSingleton(beanName);
            if (sharedInstance != null && args == null) {
                // beanFactory相关，之后再讲
                bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
            }
            else {
                // 跳过一些代码
                // 创建bean的逻辑
                if (mbd.isSingleton()) {
                    sharedInstance = getSingleton(beanName, () -> {
                        try {
                            return createBean(beanName, mbd, args);
                        }
                        catch (BeansException ex) {
                            destroySingleton(beanName);
                            throw ex;
                        }
                    });
                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
                // 跳过一些代码
            }
            // 跳过一些代码
            // 返回bean实例
            return (T) bean;
        }

        可以看到，如果我们使用getSingleton(beanName)直接获取到bean实例了，
        是会直接把bean实例返回的，我们一起看一下这个方法（这个方法属于DefaultSingletonBeanRegistry）：

        // 一级缓存，缓存正常的bean实例
        /** Cache of singleton objects: bean name to bean instance. */
        private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

        // 二级缓存，缓存还未进行依赖注入和初始化方法调用的bean实例
        /** Cache of early singleton objects: bean name to bean instance. */
        private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);

        // 三级缓存，缓存bean实例的ObjectFactory
        /** Cache of singleton factories: bean name to ObjectFactory. */
        private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);

        public Object getSingleton(String beanName) {
            return getSingleton(beanName, true);
        }

        protected Object getSingleton(String beanName, boolean allowEarlyReference) {
            // 先尝试中一级缓存获取
            Object singletonObject = this.singletonObjects.get(beanName);
            // 获取不到，并且当前需要获取的bean正在创建中
            // 第一次容器初始化触发getBean(A)的时候，这个isSingletonCurrentlyInCreation判断一定为false
            // 这个时候就会去走创建bean的流程，创建bean之前会先把这个bean标记为正在创建
            // 然后A实例化之后，依赖注入B，触发B的实例化，B再注入A的时候，会再次触发getBean(A)
            // 此时isSingletonCurrentlyInCreation就会返回true了

            // 当前需要获取的bean正在创建中时，代表出现了循环依赖（或者一前一后并发获取这个bean）
            // 这个时候才需要去看二、三级缓存
            if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
                // 加锁了
                synchronized (this.singletonObjects) {
                    // 从二级缓存获取
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null && allowEarlyReference) {
                        // 二级缓存也没有，并且允许获取早期引用的话 - allowEarlyReference传进来是true
                        ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                        // 从三级缓存获取ObjectFactory
                        if (singletonFactory != null) {
                            // 通过ObjectFactory获取bean实例
                            singletonObject = singletonFactory.getObject();
                            // 放入二级缓存
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            // 从三级缓存删除
                            // 也就是说对于一个单例bean，ObjectFactory#getObject只会调用到一次
                            // 获取到早期bean实例之后，就把这个bean实例从三级缓存升级到二级缓存了
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
            // 不管从哪里获取到的bean实例，都会返回
            return singletonObject;
        }
        一二级缓存都好理解，其实就可以理解为我们伪代码里面的那两个Map，
        但是这个三级缓存是怎么回事？ObjectFactory又是个什么东西？我们就先看一下这个ObjectFactory的结构：
        @FunctionalInterface
        public interface ObjectFactory<T> {
        	// 好吧，就是简简单单的一个获取实例的函数接口而已
        	T getObject() throws BeansException;
        }

        我们回到这个三级缓存的结构，二级缓存是是在getSingleton方法中put进去的，
        这跟我们之前分析的，创建bean实例之后放入，好像不太一样？那我们是不是可以推断一下，
        其实创建bean实例之后，是放入三级缓存的呢（总之实例创建之后是需要放入缓存的）？
        我们来跟一下bean实例化的代码，主要看一下上一篇时刻意忽略掉的地方：

        // 代码做了很多删减，只把主要的逻辑放出来的
        protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
            throws BeanCreationException {

            // 创建bean实例
            BeanWrapper instanceWrapper = createBeanInstance(beanName, mbd, args);
            final Object bean = instanceWrapper.getWrappedInstance();
        	// beanPostProcessor埋点调用
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);

            // 重点是这里了，如果是单例bean&&允许循环依赖&&当前bean正在创建
            boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
                                              isSingletonCurrentlyInCreation(beanName));
            if (earlySingletonExposure) {
                // 加入三级缓存
                addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
            }

            Object exposedObject = bean;
            try {
                // 依赖注入
                populateBean(beanName, mbd, instanceWrapper);
                // 初始化方法调用
                exposedObject = initializeBean(beanName, exposedObject, mbd);
            }
            catch (Throwable ex) {
                throw new BeanCreationException(...);
            }

            if (earlySingletonExposure) {
                // 第二个参数传false是不会从三级缓存中取值的
                Object earlySingletonReference = getSingleton(beanName, false);
                if (earlySingletonReference != null) {
                    // 如果发现二级缓存中有值了 - 说明出现了循环依赖
                    if (exposedObject == bean) {
                        // 并且initializeBean没有改变bean的引用
                        // 则把二级缓存中的bean实例返回出去
                        exposedObject = earlySingletonReference;
                    }
                }
            }

            try {
                // 注册销毁逻辑
                registerDisposableBeanIfNecessary(beanName, bean, mbd);
            }
            catch (BeanDefinitionValidationException ex) {
                throw new BeanCreationException(...);
            }

            return exposedObject;
        }

        可以看到，初始化一个bean是，创建bean实例之后，如果这个bean是单例bean&&允许循环依赖&&当前bean正在创建，
        那么将会调用addSingletonFactory加入三级缓存：
        protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
            synchronized (this.singletonObjects) {
                if (!this.singletonObjects.containsKey(beanName)) {
                    // 加入三级缓存
                    this.singletonFactories.put(beanName, singletonFactory);
                    this.earlySingletonObjects.remove(beanName);
                    this.registeredSingletons.add(beanName);
                }
            }
        }

        也就是说我们伪代码中的这一段有了：
        // 创建实例
        Object beanInstance = createBeanInstance(beanName);
        // 实例创建之后，放入缓存
        // 因为已经创建实例了，这个时候这个实例的引用暴露出去已经没问题了
        // 之后的属性注入等逻辑还是在这个实例上做的
        cacheMap.put(beanName, beanInstance);

        那么接下来，完全实例化完成的bean又是什么时候塞入我们的实例Map（一级缓存）singletonObjects的呢？
        这个时候我们就要回到调用createBean方法的这一块的逻辑了：
        if (mbd.isSingleton()) {
            // 我们回到这个位置
            sharedInstance = getSingleton(beanName, () -> {
                try {
                    return createBean(beanName, mbd, args);
                }
                catch (BeansException ex) {
                    destroySingleton(beanName);
                    throw ex;
                }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
        }
        可以看到，我们的createBean创建逻辑是通过一个lamdba语法传入getSingleton方法了，我们进入这个方法看一下：
        public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
            synchronized (this.singletonObjects) {
                Object singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    // 一级缓存拿不到
                    // 注意一下这个方法，这里会标记这个bean正在创建
                    beforeSingletonCreation(beanName);
                    boolean newSingleton = false;
                    try {
                        // 调用外部传入的lamdba，即createBean逻辑
                        // 获取到完全实例化好的bean
                        // 需要注意的是，这个时候这个bean的实例已经在二级缓存或者三级缓存中了
                        // 三级缓存：bean实例创建后放入的，如果没有循环依赖/并发获取这个bean，那会一直在三级缓存中
                        // 二级缓存：如果出现循环依赖，第二次进入getBean->getSingleton的时候，会从三级缓存升级到二级缓存
                        singletonObject = singletonFactory.getObject();
                        // 标记一下
                        newSingleton = true;
                    }
                    catch (IllegalStateException ex) {
                        singletonObject = this.singletonObjects.get(beanName);
                        if (singletonObject == null) {
                            throw ex;
                        }
                    }
                    catch (BeanCreationException ex) {
                        throw ex;
                    }
                    finally {
                        // 这里是从正在创建的列表移除，到这里这个bean要么已经完全初始化完成了
                        // 要么就是初始化失败，都需要移除的
                        afterSingletonCreation(beanName);
                    }
                    if (newSingleton) {
                        // 如果是新初始化了一个单例bean，加入一级缓存
                        addSingleton(beanName, singletonObject);
                    }
                }
                return singletonObject;
            }
        }
        哈哈，加入实例Map（一级缓存）singletonObjects的逻辑明显就是在这个addSingleton中了：
        protected void addSingleton(String beanName, Object singletonObject) {
            synchronized (this.singletonObjects) {
                // 这个逻辑应该一点也不意外吧
                // 放入一级缓存，从二、三级缓存删除，这里就用判断当前bean具体是在哪个缓存了
                // 反正都要删的
                this.singletonObjects.put(beanName, singletonObject);
                this.singletonFactories.remove(beanName);
                this.earlySingletonObjects.remove(beanName);
                this.registeredSingletons.add(beanName);
            }
        }

        也就是说，我们伪代码的这一块在spring里面也有对应的体现，完美：
        // 初始化方法调用
        initializeBean(beanName, beanInstance);
        // 从缓存移除，放入实例map
        singleMap.put(beanName, beanInstance);
        cacheMap.remove(beanName)
        就这样，spring通过缓存设计解决了循环依赖的问题。

    2.1.2. 三级缓存解决循环依赖流程图
        https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/742727a13f6e42a7b5d2942481696bd0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp

    2.1.3. 三级缓存解决循环依赖伪代码
        看完图还觉得不清晰的话，我们把所有spring中三级缓存相关的代码汇总到一起，用伪代码的方式，拍平成一个方法，大家应该感觉会更清晰了：
        // 一级缓存
        private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
        // 二级缓存
        private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);
        // 三级缓存
        private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);

        protected Object getBean(final String beanName) {
            // !以下为getSingleton逻辑！
            // 先从一级缓存获取
            Object single = singletonObjects.get(beanName);
            if (single != null) {
                return single;
            }
            // 再从二级缓存获取
            single = earlySingletonObjects.get(beanName);
            if (single != null) {
                return single;
            }
            // 从三级缓存获取objectFactory
            ObjectFactory<?> objectFactory = singletonFactories.get(beanName);
            if (objectFactory != null) {
                single = objectFactory.get();
                // 升到二级缓存
                earlySingletonObjects.put(beanName, single);
                singletonFactories.remove(beanName);
                return single;
            }
            // !以上为getSingleton逻辑！

            // ！以下为doCreateBean逻辑
            // 缓存完全拿不到，需要创建
            // 创建实例
            Object beanInstance = createBeanInstance(beanName);
            // 实例创建之后，放入三级缓存
            singletonFactories.put(beanName, () -> return beanInstance);
            // 依赖注入，会触发依赖的bean的getBean方法
            populateBean(beanName, beanInstance);
            // 初始化方法调用
            initializeBean(beanName, beanInstance);

            // 依赖注入完之后，如果二级缓存有值，说明出现了循环依赖
            // 这个时候直接取二级缓存中的bean实例
            Object earlySingletonReference = earlySingletonObjects.get(beanName);
            if (earlySingletonReference != null) {
                beanInstance = earlySingletonObject;
            }
            // ！以上为doCreateBean逻辑

            // 从二三缓存移除，放入一级缓存
            singletonObjects.put(beanName, beanInstance);
            earlySingletonObjects.remove(beanName);
            singletonFactories.remove(beanName);

            return beanInstance;
        }

    2.1.4. 标记当前bean正在创建
        在我们刚刚看到的将bean实例封装成ObjectFactory并放入三级缓存的流程中，
        有一个判断是当前bean是正在创建，这个状态又是怎么判断的呢：
        // 重点是这里了，如果是单例bean&&允许循环依赖&&当前bean正在创建
        boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            // 加入三级缓存
            addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
        }
        我们看一下这个isSingletonCurrentlyInCreation的逻辑：
        private final Set<String> singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap<>(16));
        public boolean isSingletonCurrentlyInCreation(String beanName) {
            return this.singletonsCurrentlyInCreation.contains(beanName);
        }
        可以看到,其实就是判断当前beanName是不是在这个singletonsCurrentlyInCreation容器中，那么这个容器中的值又是什么时候操作的呢？
        希望同学们还记得getSingleton(beanName, singletonFactory)中有调用的beforeSingletonCreation和afterSingletonCreation：
        public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
            synchronized (this.singletonObjects) {
                Object singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    // 一级缓存拿不到
                    // 注意一下这个方法，这里会标记这个bean正在创建
                    beforeSingletonCreation(beanName);
                    boolean newSingleton = false;
                    try {
                        // 调用外部传入的lamdba，即createBean逻辑
                        singletonObject = singletonFactory.getObject();
                        // 标记一下
                        newSingleton = true;
                    }
                    catch (BeanCreationException ex) {
                        throw ex;
                    }
                    finally {
                        // 这里是从正在创建的列表移除，到这里这个bean要么已经完全初始化完成了
                        // 要么就是初始化失败，都需要移除的
                        afterSingletonCreation(beanName);
                    }
                    if (newSingleton) {
                        // 如果是新初始化了一个单例bean，加入一级缓存
                        addSingleton(beanName, singletonObject);
                    }
                }
                return singletonObject;
            }
        }
        我们现在来看一下这两个方法的逻辑：
        protected void beforeSingletonCreation(String beanName) {
            // 加入singletonsCurrentlyInCreation，由于singletonsCurrentlyInCreation是一个set
            // 如果加入失败的话，说明在创建两次这个bean
            // 这个时候会抛出循环依赖异常
            if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }
        }

        protected void afterSingletonCreation(String beanName) {
            // 从singletonsCurrentlyInCreation中删除
            if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.remove(beanName)) {
                throw new IllegalStateException("Singleton '" + beanName + "' isn't currently in creation");
            }
        }

        可以看到，我们这两个方法主要就是对singletonsCurrentlyInCreation容器进行操作的，
        inCreationCheckExclusions这个容器可以不用管它，这名称一看就是一些白名单之类的配置。
        这里需要主要的是beforeSingletonCreation中，如果singletonsCurrentlyInCreation.add(beanName)失败的话，
        是会抛出BeanCurrentlyInCreationException的，这代表spring遇到了无法解决的循环依赖问题，此时会抛出异常中断初始化流程，毕竟单例的bean不允许被创建两次。

    2.2. 为什么要设计为三级结构？
    2.2.1. 只做两级缓存会有什么问题？
        其实到这里，我们已经清楚，三级缓存的设计已经成功的解决了循环依赖的问题。
        可是按我们自己的设计思路，明明只需要两级缓存就可以解决，spring却使用了三级缓存，难道是为了炫技么？
        这个时候，就需要我们再细致的看一下bean初始化过程了：
        protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
            throws BeanCreationException {
            // ...
            if (earlySingletonExposure) {
                // 放入三级缓存
                addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
            }
            Object exposedObject = bean;
            try {
                populateBean(beanName, mbd, instanceWrapper);
                // 这里这个引用被替换了
                exposedObject = initializeBean(beanName, exposedObject, mbd);
            }
            // ...
            return exposedObject;
        }
        仔细观察，initializeBean方法是可能返回一个新的对象，从而把createBeanInstance创建的bean实例替换掉的：
        protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
            // 调用aware接口
            invokeAwareMethods(beanName, bean);
            Object wrappedBean = bean;
            if (mbd == null || !mbd.isSynthetic()) {
                // 埋点
                wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
            }

            try {
                // 初始化方法
                invokeInitMethods(beanName, wrappedBean, mbd);
            }
            catch (Throwable ex) {
                throw new BeanCreationException(...);
            }
            if (mbd == null || !mbd.isSynthetic()) {
                // 埋点
                wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
            }

            return wrappedBean;
        }
        可以看到，我们的postProcessBeforeInitialization和postProcessAfterInitialization的埋点方法都是有可能把我们的bean替换掉的。
        那么结合整个流程来看，由于我们放入缓存之后，initializeBean方法中可能存在替换bean的情况，如果只有两级缓存的话：
        https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41e0e855f8f14a8197e4fefb738546a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp

        这会导致B中注入的A实例与singletonObjects中保存的AA实例不一致，
        而之后其他的实例注入a时，却会拿到singletonObjects中的AA实例，这样肯定是不符合预期的。

    2.2.2. 三级缓存是如何解决问题的
        那么这个问题应该怎么解决呢？
        这个时候我们就要回到添加三级缓存的地方看一下了。
        addSingletonFactory的第二个参数就是一个ObjectFactory，
        并且这个ObjectFactory最终将会放入三级缓存，现在我们再回头看调用addSingletonFactory的地方：

         // 加入三级缓存
        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));

        原来为了解决initializeBean可能替换bean引用的问题，spring就设计了这个三级缓存，
        他在第三级里保存了一个ObjectFactory，其实具体就是getEarlyBeanReference的调用，
        其中提供了一个getEarlyBeanReference的埋点方法，通过这个埋点方法，它允许开发人员把需要替换的bean，提早替换出来。

        比如说如果在initializeBean方法中希望把A换成AA（这个逻辑肯定是通过某个beanPostProcessor来做的），
        那么你这个beanPostProcessor可以同时提供getEarlyBeanReference方法，在出现循环依赖的时候，
        可以提前把A->AA这个逻辑做了，并且initializeBean方法不再做这个A->AA的逻辑，
        并且，当我们的循环依赖逻辑走完，A创建->注入B->触发B初始化->注入A->执行缓存逻辑获取AA实例并放入二级缓存->B初始化完成->回到A的初始化逻辑时，通过以下代码：
        protected Object doCreateBean(...) {
            populateBean(beanName, mbd, instanceWrapper);
            Object exposedObject = initializeBean(beanName, exposedObject, mbd);

            if (earlySingletonExposure) {
                Object earlySingletonReference = getSingleton(beanName, false);
                if (earlySingletonReference != null) {
                    if (exposedObject == bean) {
                        // 如果二级缓存存在，直接使用二级缓存
                        exposedObject = earlySingletonReference;
                    }
                }
            }
            return exposedObject;
        }

        这样就能保证当前bean中注入的AA和singletonObjects中的AA实例是同一个对象了。
        将会把二级缓存中的AA直接返回，这是就能保证B中注入的AA实例与spring管理起来的最终的AA实例是同一个了。
        整个流程梳理一下就是这样：
        https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaca2190df3f4b7b85e45423e9e3aee0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp

    2.2.3. 三级缓存的实际应用
        既然设计了这个三级缓存，那么肯定是有实际需求的，我们上面分析了一大堆，现在正好举一个例子看一下，为什么spring需要三级缓存。
        我们都知道，Spring的AOP功能，是通过生成动态代理类来实现的，而最后我们使用的也都是代理类实例而不是原始类实例。
        而AOP代理类的创建，就是在initializeBean方法的postProcessAfterInitialization埋点中，
        我们直接看一下getEarlyBeanReference和postProcessAfterInitialization这两个埋点吧（具体类是AbstractAutoProxyCreator，之后讲AOP的时候会细讲）：

        public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport
            implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware {

            private final Map<Object, Object> earlyProxyReferences = new ConcurrentHashMap<>(16);
            // 如果出现循环依赖，getEarlyBeanReference会先被调用到
            public Object getEarlyBeanReference(Object bean, String beanName) {
                Object cacheKey = getCacheKey(bean.getClass(), beanName);
                // 这个时候把当前类放入earlyProxyReferences
                this.earlyProxyReferences.put(cacheKey, bean);
                // 直接返回了一个代理实例
                return wrapIfNecessary(bean, beanName, cacheKey);
            }

            public Object postProcessAfterInitialization(Object bean, String beanName) {
                if (bean != null) {
                    Object cacheKey = getCacheKey(bean.getClass(), beanName);
                    // 注意这个判断，如果出现了循环依赖，这个if块是进不去的
                    if (this.earlyProxyReferences.remove(cacheKey) != bean) {
                        // 如果没有出现循环依赖，会在这里创建代理类
                        return wrapIfNecessary(bean, beanName, cacheKey);
                    }
                }
                return bean;
            }
        }
        就这样，Spring巧妙的使用三级缓存来解决了这个不同实例的问题。
        当然，如果我们需要自己开发类似代理之类的可能改变bean引用的功能时，
        也需要遵循getEarlyBeanReference方法的埋点逻辑，学习AbstractAutoProxyCreator中的方式，才能让spring按照我们的预期来工作。

    四、三级缓存无法解决的问题
        1. 构造器循环依赖
        刚刚讲了很多三级缓存的实现，以及它是怎么解决循环依赖的问题的。
        但是，是不是使用了三级缓存，就能解决所有的循环依赖问题呢？
        当然不是的，有一个特殊的循环依赖，由于java语言特性的原因，是永远无法解决的，那就是构造器循环依赖。
        比如以下两个类：
        public class A {
            private final B b;
            public A(final B b) {
                this.b = b;
            }
        }
        public class B {
            private final A a;
            public B(final A a) {
                this.a = a;
            }
        }

        2. Spring真的对构造器循环依赖束手无策么？
        难道，spring对于这种循环依赖真的束手无策了么？其实不是的，spring还有@Lazy这个大杀器...只需要我们对刚刚那两个类小小的改造一下：
        @Service
        public class A {
            private final B b;
            public A(final B b) {
                this.b = b;
            }
            public void prt() {
                System.out.println("in a prt");
            }
        }
        @Service
        public class B {
            private final A a;
            public B(@Lazy final A a) {
                this.a = a;
            }
            public void prt() {
                a.prt();
            }
        }
        // 启动
        @Test
        public void test() {
            applicationContext = new ClassPathXmlApplicationContext("spring.xml");
            B bean = applicationContext.getBean(B.class);
            bean.prt();
        }

    3. @Lazy原理
        这个时候我们必须要想一下，spring是怎么通过 @Lazy来绕过我们刚刚解决不了的无限套娃问题了。
        因为这里涉及到之前没有细讲的参数注入时候的参数解析问题，我这边就不带大家从入口处一步一步深入了，
        这边直接空降到目标代码DefaultListableBeanFactory#resolveDependency：

        public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
                                        @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {
            // 跳过...
            // 这个地方是我们获取依赖的地方
            // 尝试获取一个懒加载代理
            Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
                descriptor, requestingBeanName);
            if (result == null) {
                // 如果没获取到懒加载代理，就直接去获取bean实例了，这里最终会调用getBean
                result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
            }
            return result;
        }

        我们直接看一下这个getLazyResolutionProxyIfNecessary，这个方法就是获取LazyProxy的地方了：
        public class ContextAnnotationAutowireCandidateResolver extends QualifierAnnotationAutowireCandidateResolver {

            @Override
            @Nullable
            public Object getLazyResolutionProxyIfNecessary(DependencyDescriptor descriptor, @Nullable String beanName) {
                // 如果是懒加载的，就构建一个懒加载的代理
                return (isLazy(descriptor) ? buildLazyResolutionProxy(descriptor, beanName) : null);
            }
        	// 判断是否是懒加载的，主要就是判断@Lazy注解，简单看下就好了
            protected boolean isLazy(DependencyDescriptor descriptor) {
                for (Annotation ann : descriptor.getAnnotations()) {
                    Lazy lazy = AnnotationUtils.getAnnotation(ann, Lazy.class);
                    if (lazy != null && lazy.value()) {
                        return true;
                    }
                }
                MethodParameter methodParam = descriptor.getMethodParameter();
                if (methodParam != null) {
                    Method method = methodParam.getMethod();
                    if (method == null || void.class == method.getReturnType()) {
                        Lazy lazy = AnnotationUtils.getAnnotation(methodParam.getAnnotatedElement(), Lazy.class);
                        if (lazy != null && lazy.value()) {
                            return true;
                        }
                    }
                }
                return false;
            }

            protected Object buildLazyResolutionProxy(final DependencyDescriptor descriptor, final @Nullable String beanName) {
                final DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) getBeanFactory();
                // 构造了一个TargetSource
                TargetSource ts = new TargetSource() {
                    @Override
                    public Class<?> getTargetClass() {
                        return descriptor.getDependencyType();
                    }
                    @Override
                    public boolean isStatic() {
                        return false;
                    }
                    @Override
                    public Object getTarget() {
                        // 再对应的getTarget方法里，才会去正真加载依赖，进而调用getBean方法
                        Object target = beanFactory.doResolveDependency(descriptor, beanName, null, null);
                        if (target == null) {
                            Class<?> type = getTargetClass();
                            if (Map.class == type) {
                                return Collections.emptyMap();
                            }
                            else if (List.class == type) {
                                return Collections.emptyList();
                            }
                            else if (Set.class == type || Collection.class == type) {
                                return Collections.emptySet();
                            }
                            throw new NoSuchBeanDefinitionException(...);
                        }
                        return target;
                    }
                    @Override
                    public void releaseTarget(Object target) {
                    }
                };
                // 创建代理工厂ProxyFactory
                ProxyFactory pf = new ProxyFactory();
                pf.setTargetSource(ts);
                Class<?> dependencyType = descriptor.getDependencyType();
                if (dependencyType.isInterface()) {
                    pf.addInterface(dependencyType);
                }
                // 创建返回代理类
                return pf.getProxy(beanFactory.getBeanClassLoader());
            }
        }
        同学们可能对TargetSource和ProxyFactory这些不熟悉，没关系，这不妨碍我们理解逻辑。
        从源码我们可以看到，对于@Lazy的依赖，我们其实是返回了一个代理类（以下称为LazyProxy）而不是正真通过getBean拿到目标bean注入。
        而真正的获取bean的逻辑，被封装到了一个TargetSource类的getTarget方法中，而这个TargetSource类最终被用来生成LazyProxy了，
        那么我们是不是可以推测，LazyProxy应该持有这个TargetSource对象。
        而从我们懒加载的语意来讲，是说真正使用到这个bean（调用这个bean的某个方法时）的时候，才对这个属性进行注入/初始化。
        那么对于当前这个例子来讲，就是说其实B创建的时候，并没有去调用getBean("a")去获取构造器的参数，
        而是直接生成了一个LazyProxy来做B构造器的参数，而B之后正真调用到A的方法时，才会去调用TargetSource中的getTarget获取A实例，即调用getBean("a")，
        这个时候A早就实例化好了，所以也就不会有循环依赖问题了。

    4. 伪代码描述
        还是同样，我们可以用伪代码来描述一下这个流程，伪代码我们就直接用静态代理来描述了：
        public class A {
            private final B b;
            public A(final B b) {
                this.b = b;
            }
            public void prt() {
                System.out.println("in a prt");
            }
        }

        public class B {
            private final A a;
            public B(final A a) {
                this.a = a;
            }
            public void prt() {
                a.prt();
            }
        }
        // A的懒加载代理类
        public class LazyProxyA extends A {
            private A source;
            private final Map<String, Object> ioc;
            private final String beanName;
            public LazyProxyA(Map<String, Object> ioc, String beanName) {
                super(null);
                this.ioc = ioc;
                this.beanName = beanName;
            }
            @Override
            public void prt() {
                if (source == null) {
                    source = (A) ioc.get(beanName);
                }
                source.prt();
            }
        }
        那么整个初始化的流程简单来描述就是：
        Map<String, Object> ioc = new HashMap<>();
        void init() {
            B b = new B(new LazyProxyA(ioc, "a"));
            ioc.put("b", b);
            A a = new A((B)ioc.get("b"));
            ioc.put("a", a);
        }

   六、总结
        关于循环依赖的问题，Spring提供了通过设计缓存的方式来解决的，而设计为三级缓存，
        主要是为了解决bean初始化过程中，实例被放入缓存之后，实例的引用还可能在调用initializeBean方法时被替换的问题。
        对于构造器的循环依赖，三级缓存设计是无法解决的，这属于java语言的约束；
        但是spring提供了一种使用@Lazy的方式，绕过这个限制，使得构造器的循环依赖在特定情况下（循环链中的某个注入打上@Lazy注解）也能解决。

六.逐行解读Spring（六）- FactoryBean的亿点点细节
    二、FactoryBean的作用
        在讲原理之前，我们还是简单的讲一下FactoryBean接口的作用。我们首先看一下FactoryBean的定义：
        public interface FactoryBean<T> {
        	@Nullable
        	T getObject() throws Exception;

        	@Nullable
        	Class<?> getObjectType();
        	// FactoryBean#getObject返回的bean实例是否是单例的
            // 如果是单例，那么FactoryBean#getObject将只会被调用一次
        	default boolean isSingleton() {
        		return true;
        	}
        }

        然后我们写一个类实现一下这个接口：
        public class SubBean {
        }
        @Service
        public class FactoryBeanDemo implements FactoryBean<SubBean> {
            @Override
            public SubBean getObject() throws Exception {
                return new SubBean();
            }
            @Override
            public Class<?> getObjectType() {
                return SubBean.class;
            }
        }
        我们启动Spring打印一下这个factoryBeanDemo：
        public void test() {
            applicationContext = new AnnotationConfigApplicationContext("com.xiaoxizi.spring");
            Object subBean = applicationContext.getBean("factoryBeanDemo");
            System.out.println(subBean);
        }
        输出：com.xiaoxizi.spring.factoryBean.SubBean@3e0e1046
        可以看到，我们通过getBean("factoryBeanDemo")拿到的居然是SubBean的实例，
        而不是我们@Service注解标记的FactoryBeanDemo的实例。

        这就是FactoryBean接口的用途啦，当我们向spring注册一个FactoryBean时，
        通过beanName获取到的将是FactoryBean#getObject方法返回的subBean（我们使用subBean来表示factoryBean#getObject的返回对象）实例，
        而且注意看FactoryBean#isSingleton方法，说明我们也是可以指定getObject方法获取的实例是单例的还是多例的。

        那么，在这种情况，我们还能获取到FactoryBeanDemo的实例么？当然也是可以的，只不过我们需要稍微做一点改变：

        public void test() {
            applicationContext = new AnnotationConfigApplicationContext("com.xiaoxizi.spring");
            Object subBean = applicationContext.getBean("factoryBeanDemo");
            System.out.println(subBean);

            Object factoryBeanDemo = applicationContext.getBean("&factoryBeanDemo");
            System.out.println(factoryBeanDemo);
        }
        也就是说，正常通过beanName从Spring容器中取的话，是只能取到subBean实例的，
        但是如果在beanName前面加上&符号，使用&beanName从Spring容器中获取，才能获取到FactoryBean实例本身。

    三、源码解析
        那么Spring是如何支撑FactoryBean的功能的呢？我们还是一起跟源码看一下。
        我们之前讲bean的生命周期的时候，有讲到单例的bean都是在Spring容器启动的时候就初始化的，
        那么对于FactoryBean实例，它的FactoryBean#getObject方法也会在Spring容器启动的时候就初始化嘛？
        subBean实例又储存在哪里呢？带着这些疑问，我们来看一下获取bean的核心逻辑AbstractBeanFactory#doGetBean方法：
        protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
                                  @Nullable final Object[] args, boolean typeCheckOnly) {
        	// 转换一下需要获取的beanName
            final String beanName = transformedBeanName(name);
            Object bean;

            // 直接从一级缓存获取单例对象
            Object sharedInstance = getSingleton(beanName);
            if (sharedInstance != null && args == null) {
                // 获取最终返回的bean实例，FactoryBean的主要处理逻辑在这里
                bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
            } else {
                // skip...
                if (mbd.isSingleton()) {
                    // spring容器启动的时候会走到这个分支
                    // 触发当前bean的初始化流程
                    sharedInstance = getSingleton(beanName, () -> {
                        try {
                            return createBean(beanName, mbd, args);
                        }
                        catch (BeansException ex) {
                            destroySingleton(beanName);
                            throw ex;
                        }
                    });
                    // 初始化单例bean之后，拿到这个bean对象，最终也会调用这个方法
                    // 获取最终返回的bean实例，FactoryBean的主要处理逻辑在这里
                    // 需要注意的是，bean实例初始化之后调用的时候，多传了一个BeanDefinition参数
                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
                else if (mbd.isPrototype()) {
                    // 多例的bean
                    Object prototypeInstance = null;
                    try {
                        beforePrototypeCreation(beanName);
                        prototypeInstance = createBean(beanName, mbd, args);
                    }
                    finally {
                        afterPrototypeCreation(beanName);
                    }
                    // 多例的时候也会调用
                    // 需要注意的是，bean实例初始化之后调用的时候，多传了一个BeanDefinition参数
                    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                }else {
                    // 其他自定义scope
                    String scopeName = mbd.getScope();
                    final Scope scope = this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException(..);
                    }
                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            beforePrototypeCreation(beanName);
                            try {
                                return createBean(beanName, mbd, args);
                            }
                            finally {
                                afterPrototypeCreation(beanName);
                            }
                        });
                        // 最后也是需要调用这个方法的
                        // 需要注意的是，bean实例初始化之后调用的时候，多传了一个BeanDefinition参数
                        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    }
                    catch (IllegalStateException ex) {
                        throw new BeanCreationException(...);
                    }
                }
            }
            }
        }

        1. transformedBeanName处理&符号
            刚刚在测试的时候，我们有看到，使用getBean("&factoryBeanDemo")是可以获取到factoryBean的实例的，
            那么对于这个&符号，spring是在transformedBeanName中做初步处理的：
            // AbstractBeanFactory#transformedBeanName
            protected String transformedBeanName(String name) {
                // canonicalName 主要是通过别名找beanName的逻辑，逻辑也简单，不过我们不关注
                // 就不看了，而且别名其实用的很少
                // 主要看一下 BeanFactoryUtils.transformedBeanName
                return canonicalName(BeanFactoryUtils.transformedBeanName(name));
            }
            // BeanFactoryUtils#transformedBeanName
            public static String transformedBeanName(String name) {
                // 先说一下，这个BeanFactory.FACTORY_BEAN_PREFIX常量就是 & 符号
                if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {
                    // 如果不是以 & 符号开头，那就直接返回了
                    return name;
                }
                return transformedBeanNameCache.computeIfAbsent(name, beanName -> {
                    // 把name的所有前置的&符号全部干掉
                    // 比如 &&&factoryBean --> factoryBean
                    do {
                        beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());
                    }
                    while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));
                    return beanName;
                });
            }
            也就是说，对于我们getBean("&factoryBeanDemo")的调用，经过transformedBeanName(name)这一步之后，
            返回的beanName就是"factoryBeanDemo"了。

        2. getObjectForBeanInstance获取最终需要返回的bean实例
            不管是调用getBean时，是触发创建初始化bean流程（单例容器初始化/多例每次调用都会创建bean实例），
            还是直接从一级缓存获取到单例实例最终都需要使用获取到的bean实例调用getObjectForBeanInstance获取最终需要返回的bean，
            而我们的FactoryBean的逻辑就是在这个地方处理的：
            // 需要注意的是，这里传入了name和beanName两个值
            // name是transformedBeanName之前的原始值，也就是我们调用getBean方法时传入的
            // beanName就是转换后的啦，正常情况下（name没有前置的&标记），这两是一样的
            // 如果mbd不为空，说明bean对象刚刚初始化完
            protected Object getObjectForBeanInstance(
                Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {
                if (BeanFactoryUtils.isFactoryDereference(name)) {
                    // 如果name是带有&前缀的，说明我们是想获取factoryBean实例
                    // 而不是获取factoryBean#getObject返回的实例
                    if (beanInstance instanceof NullBean) {
                        return beanInstance;
                    }
                    // 判断一下，如果你通过&xxx来获取bean实例，那你获取到的bean实例必须实现FactoryBean接口
                    // 这种判断主要是杜绝意料之外的事情发生，比较beanName是用户指定的
                    // 要是用户指定一个bean名称是&xxx但是实际上是不实现FactoryBean是不允许的
                    // 启动就会报错
                    if (!(beanInstance instanceof FactoryBean)) {
                        throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());
                    }
                    if (mbd != null) {
                        mbd.isFactoryBean = true;
                    }
                    // 这里就直接把factoryBean实例返回出去了
                    // 这就是我们getBean("&factoryBeanDemo")获取到factoryBean实例的原因
                    return beanInstance;
                }

                // 能走到这里，其实说明name是一个正常的非&开头的name了
                if (!(beanInstance instanceof FactoryBean)) {
                    // 这个时候，如果获取到的bean实例没有实现FactoryBean接口，
                    // 是不需要特殊处理的，直接返回就行了
                    // 对于正常的bean（没实现FactoryBean的），都是往这里返回的
                    return beanInstance;
                }

                Object object = null;
                if (mbd != null) {
                    // 如果mbd不为空，说明bean对象（FactoryBean）刚刚初始化完
                    mbd.isFactoryBean = true;
                }
                else {
                    // 不是bean对象（FactoryBean）刚刚初始化完，直接从缓存获取
                    object = getCachedObjectForFactoryBean(beanName);
                }
                if (object == null) {
                    // 如果缓存中没有这个factoryBean对应的subBean
                    // 或者是factoryBean刚初始化完的时候
                    FactoryBean<?> factory = (FactoryBean<?>) beanInstance;
                    if (mbd == null && containsBeanDefinition(beanName)) {
                        mbd = getMergedLocalBeanDefinition(beanName);
                    }
                    boolean synthetic = (mbd != null && mbd.isSynthetic());
                    // 从factoryBean获取subBean并且返回
                    object = getObjectFromFactoryBean(factory, beanName, !synthetic);
                }
                // 这里返回了subBean
                return object;
            }
            可以看到，如果a实例是一个factoryBean的话，当我们调用getBean("a")时，
            是会创建a实例并触发它的factoryBean#getObject获取到subBean实例并返回的；
            而如果是使用getBean("&a")，则只会实例化a实例并返回factoryBean本身。

        2.1. getCachedObjectForFactoryBean从缓存获取subBean
            可以看到，当调用getObjectForBeanInstance方法的最后一个参数BeanDefinition为空的时候，
            代表factoryBean实例是已经创建好了，这个时候会通过getCachedObjectForFactoryBean方法尝试直接从缓存中获取subBean对象，这个方法的逻辑很简单：
            // 当前类是 FactoryBeanRegistrySupport
            private final Map<String, Object> factoryBeanObjectCache = new ConcurrentHashMap<>(16);
            protected Object getCachedObjectForFactoryBean(String beanName) {
                // 直接从缓存中拿了
                return this.factoryBeanObjectCache.get(beanName);
            }
            如果缓存中有subBean实例，就直接返回这个实例，如果没有，则还会继续走下面的获取subBean的逻辑。
        2.2. getObjectFromFactoryBean从factoryBean获取subBean
            假设缓存中还没有subBean实例，那么肯最终都会走到getObjectFromFactoryBean方法，来获取一个subBean对象：
            protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {
                // 注意这个isSingleton是FactoryBean#isSingleton
                // 也就是说factoryBean是单例-containsSingleton(beanName)，
                // 且subBean也定义为单例时，才会把subBean缓存起来
                if (factory.isSingleton() && containsSingleton(beanName)) {
                    synchronized (getSingletonMutex()) {
                        // 加锁
                        // 先从缓存拿一次
                        Object object = this.factoryBeanObjectCache.get(beanName);
                        if (object == null) {
                            // 确保缓存没有，才创建一个
                            // 这里就是简单的调用FactoryBean#getObject了，就不往下跟了
                            object = doGetObjectFromFactoryBean(factory, beanName);
                            // Only post-process and store if not put there already during getObject() call above
                            // (e.g. because of circular reference processing triggered by custom getBean calls)
                            Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
                            if (alreadyThere != null) {
                                // 再从缓存中获取一遍，如果缓存中存在对象了，则把当前对象覆盖
                                // 并且会跳过subBean的beanPostProcessor调用流程
                                // 这里其实是用来解决循环依赖问题的
                                // 同学们可以思考一下，什么场景下，会走到这个分支呢？
                                object = alreadyThere;
                            }
                            else {
                                // 正常流程是走这里，到这里我们已经拿到subBean实例了
                                if (shouldPostProcess) {
                                    // 如果当前subBean已经在创建中了，那就直接返回了。
                                    // 其实就是判断在不在singletonsCurrentlyInCreation这个容器里
                                    if (isSingletonCurrentlyInCreation(beanName)) {
                                        return object;
                                    }
                                    // 把当前beanName加入singletonsCurrentlyInCreation容器（set）
                                    // 如果加入不进去会报循环依赖错误，同学们应该要眼熟这个容器了才对
                                    beforeSingletonCreation(beanName);
                                    try {
                                        // 调用beanPostProcessor，由于subBean的初始化/销毁等生命周期
                                        // 都是由factoryBean自行管理的，所以这里就是调用了bean完全实例化之后的
                                        // postProcessAfterInitialization方法
                                        // AOP切面就是在这个埋点里做的
                                        object = postProcessObjectFromFactoryBean(object, beanName);
                                    }
                                    catch (Throwable ex) {
                                        throw new BeanCreationException(...);
                                    }
                                    finally {
                                        // 从singletonsCurrentlyInCreation容器删除
                                        afterSingletonCreation(beanName);
                                    }
                                }
                                if (containsSingleton(beanName)) {
                                    // 最后放入缓存
                                    this.factoryBeanObjectCache.put(beanName, object);
                                }
                            }
                        }
                        return object;
                    }
                }
                else {
                    // 非单例就直接创建一个了
                    Object object = doGetObjectFromFactoryBean(factory, beanName);
                    if (shouldPostProcess) {
                        try {
                            // 调用BeanPostProcessor
                            object = postProcessObjectFromFactoryBean(object, beanName);
                        }
                        catch (Throwable ex) {
                            throw new BeanCreationException(...);
                        }
                    }
                    // 返回
                    return object;
                }
            }
            我们简单看一下这个postProcessObjectFromFactoryBean：
            protected Object postProcessObjectFromFactoryBean(Object object, String beanName) {
                return applyBeanPostProcessorsAfterInitialization(object, beanName);
            }

            // 其实这个方法就是bean初始化流程中，initializeBean方法里，bean完全初始化完之后调用的埋点方法
            // 由于subBean把整个生命周期(初始化、依赖注入)交由factoryBean处理了（即用户自定义）
            // 所以它只需要再调用这个埋点就行
            public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
                throws BeansException {

                Object result = existingBean;
                for (BeanPostProcessor processor : getBeanPostProcessors()) {
                    Object current = processor.postProcessAfterInitialization(result, beanName);
                    if (current == null) {
                        return result;
                    }
                    result = current;
                }
                return result;
            }
            可以看到，其实最终调用到的applyBeanPostProcessorsAfterInitialization方法就是bean初始化流程中，
            initializeBean方法里，bean完全初始化完之后调用的埋点方法。aop也是在这个埋点做操作的，所以我们的subBean也是能使用aop的功能的。
        3. subBean的初始化时机
            我们已经了解了getBean中对factoryBean的处理逻辑，简单的来讲，其实就是针对传入的name是否有&前缀，来走不同的分支逻辑。
            那么现在又有一个问题了，单例的subBean对象，到底是在什么时候创建并且被spring管理起来的呢?
            我们知道，如果subBean缓存factoryBeanObjectCache中没有对于的subBean，那么直接调用getBean("factoryBeanDemo")肯定是会创建一个subBean的，
            现在我想说的是，我们普通的单例bean会在spring容器启动的时候就初始化，单例的subBean也会在这个时候初始化么？
            要清楚这个问题，我们还是要直接去看源码，这个时候就需要看spring容器启动时，初始化所有单例bean的逻辑了：
            // DefaultListableBeanFactory类中
            public void preInstantiateSingletons() throws BeansException {
            	// 获取所以的beanName
                List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

                for (String beanName : beanNames) {
                    // 循环逐一处理
                    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
                    if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
                        // 单例的非抽象非懒加载的才需要实例化
                        if (isFactoryBean(beanName)) {
                            // 这里主要是通过beanDefinition中的信息，判断一下是否是factoryBean
                            // 如果是factoryBean，将会在beanName前面加上一个&符合再调用getBean
                            // 也就是说这个getBean是不会初始化subBean实例的
                            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                            if (bean instanceof FactoryBean) {
                                // 拿到bean的实例之后，就可以通过bean实例使用instanceof进行二次确认了
                                final FactoryBean<?> factory = (FactoryBean<?>) bean;
                                // 可以看到这里出现了一个SmartFactoryBean接口，且有一个isEagerInit方法
                                // 如果isEagerInit方法返回true，spring就认为这个subBean是需要提前初始化
                                boolean isEagerInit = (factory instanceof SmartFactoryBean &&
                                                      ((SmartFactoryBean<?>) factory).isEagerInit());
                                if (isEagerInit) {
                                    // 这个时候使用原始的beanName再调用一次getBean
                                    // 这里就会触发subBean的初始化流程了
                                    getBean(beanName);
                                }
                            }
                        }
                        else {
                            // 普通的bean直接走这里
                            getBean(beanName);
                        }
                    }
                }
                // 跳过
            }
            可以看到，对于我们的普通的subBean，在spring容器启动的时候，是不会主动去初始化的，
            而只会初始化factoryBean对象。除非我们的factoryBean实现了FactoryBean的子接口SmartFactoryBean并表明该subBean需要提前初始化。

            public interface SmartFactoryBean<T> extends FactoryBean<T> {
                // 跟FactoryBean#isSingleton()差不多，但是用处稍微有点不一样
            	default boolean isPrototype() {
            		return false;
            	}
                // 这个方法表明是否需要提前初始化
            	default boolean isEagerInit() {
            		return false;
            	}
            }
        4. subBean的循环依赖问题
            我们之前讲循环依赖的时候，都是基于两个普通的bean来讲解的，
            而循环依赖现象是指spring在进行单例bean的依赖注入时，出现A->B，B->A的问题。
            同学们可能会说，subBean的依赖注入都不归spring管理了，怎么还能出现循环依赖问题的？
            首先需要明确一点的是，循环依赖其实跟spring没有关系的，只要出现了A->B，B->A的情况，
            我们就认为A、B实例出现了循环依赖。而spring只是在它的管理的范围内，巧妙的使用了三级缓存/@Lazy解决了循环依赖而已。
            而由于factoryBean实例本身就是由spring容器管理的，那么我们做以下操作，也是合理的：
            @Getter
            @ToString
            @AllArgsConstructor
            public class SubBean {
                private A a;
            }

            @Component
            public class A {
                @Autowired
                private SubBean subBean;
            }

            @Service
            public class FactoryBeanDemo implements FactoryBean<SubBean>, BeanFactoryAware {
                private BeanFactory beanFactory;

                @Override
                public void setBeanFactory(final BeanFactory beanFactory) throws BeansException {
                    this.beanFactory = beanFactory;
                }

                @Override
                public SubBean getObject() throws Exception {
                    final A bean = this.beanFactory.getBean(A.class);
                    return new SubBean(bean);
                }
            }

            我们factoryBean通过BeanFactoryAware接口拿到beanFactory实例，
            并且在工厂方法getObject获取subBean的流程中使用beanFactory.getBean(A.class)从spring容器中获取a实例，而a实例又是依赖subBean实例的...

        3.1. 先初始化a实例
            对于先初始化a实例的场景，其实spring原有的三级缓存设计就可以很好的解决这个问题。
            同学们可以回想一下，我们在创建a实例之后，尚未进行依赖注入subBean之前，
            就把a实例暴露到缓存了。而注入subBean的时候，会触发FactoryBean#getObject方法，
            最终会调用到我们自己写的beanFactory.getBean(A.class)的逻辑，从缓存中获取到暴露到缓存的a实例。
            那么按这个流程下来，其实整体是没问题的，spring的三级缓存的设计已经很好的解决了这种循环依赖的问题。
            https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/198426bd7f64480bb28d9754efabd86d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp

        3.2. 先初始化subBean实例
            刚刚讲subBean的初始化时机时，其实有讲过，正常的subBean的初始化是一种类似于懒加载的方式，
            也就是说它是不会在a初始化化之前触发初始化的。但是有时候我们的项目中，实例的依赖关系可能不是这么清晰的。
            假设我们有一个c实例，它依赖subBean实例，而subBean实例又和a实例循环依赖。那如果c实例先于a实例初始化，
            就会出现subBean实例先于a实例初始化的情况了。由于我们的subBean是没有多级缓存的机制来解决循环依赖问题，那么这个时候，整个初始化流程就变成了：
            https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1a1936bad914f9dbd4e5337e263676d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp
            可以看到，如果没有特殊处理的话，尽管由于我们的普通bean有三级缓存的设计，
            不会出现完全无法解决的级联创建实例问题。但是，也会导致我们的factoryBean#getObject被调用两次，
            生成两个subBean对象，且最终factoryBeanObjectCache缓存中的subBean1对象与a实例中注入的subBean2对象不是同一个。
            那么这个情况应该如何解决呢？有同学可能会说，使用多级缓存呀，和普通的bean一个思路就可以了。
            但是，多级缓存的思路，其实主要就是在bean实例创建之后，依赖注入之前，将bean实例暴露到缓存中，
            进而解决循环依赖的问题。然而，我们刚刚举例中，实际是在factoryBean#getObject获取subBean实例的过程中进行了依赖注入
            （虽然是我们手动的调用beanFactory.getBean获取的依赖），这个情况其实有点类似于构造器注入依赖了，
            构造器循环依赖用多级缓存的思想也解决不了哇。那么对于两个subBean实例的问题，spring是怎么解决的呢？spring通过短短几行代码，就解决了这个问题：
            protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {
                // 注意这个isSingleton是FactoryBean#isSingleton
                // 也就是说factoryBean是单例-containsSingleton(beanName)，
                // 且subBean也定义为单例时，才会把subBean缓存起来
                if (factory.isSingleton() && containsSingleton(beanName)) {
                    synchronized (getSingletonMutex()) {
                        // 加锁
                        // 先从缓存拿一次
                        Object object = this.factoryBeanObjectCache.get(beanName);
                        if (object == null) {
                            // 确保缓存没有，才创建一个
                            // 这里就是简单的调用FactoryBean#getObject了，就不往下跟了
                            object = doGetObjectFromFactoryBean(factory, beanName);
                            Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
                            if (alreadyThere != null) {
                                // 再从缓存中获取一遍，如果缓存中存在对象了，则把当前对象覆盖
                                // 并且会跳过subBean的beanPostProcessor调用流程
                                // 这里其实是用来解决循环依赖问题的
                                object = alreadyThere;
                            }
                            else {
                                // 跳过调用beanPostProcessor的逻辑
                                this.factoryBeanObjectCache.put(beanName, object);
                            }
                        }
                        return object;
                    }
                }
                // 跳过
            }
            这里再factoryBean#getObject方法获取到subBean1之后，再次从factoryBeanObjectCache获取了一遍subBean实例，
            如果获取到了subBean2，其实就代表出现我们举例的那种循环依赖了，导致缓存中已经有subBean实例了。
            此时会把subBean2赋值给object并且返回出去，subBean1就直接丢弃掉了，也不会放入缓存。这样就巧妙的解决了两个subBean的问题啦~
            https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/701d4940a95b409aaf98f2844ebcb9a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp

        3.3. 无法解决的循环依赖问题
            刚刚我们有聊到，factoryBean#getObject中使用beanFactory#getBean进行依赖注入，本质上相当于是构造器注入。
            而上一篇讲循环缓存的时候，我们也有讲过，正常情况下来讲，构造器循环依赖是无法解决的：
            @Getter
            @ToString
            @AllArgsConstructor
            public class SubBean {
                private A a;
            }

            @Component
            public class A {
                public A(final SubBean subBean) {
                    this.subBean = subBean;
                }
                private SubBean subBean;
            }

            @Service
            public class FactoryBeanDemo implements FactoryBean<SubBean>, BeanFactoryAware {
                private BeanFactory beanFactory;

                @Override
                public void setBeanFactory(final BeanFactory beanFactory) throws BeansException {
                    this.beanFactory = beanFactory;
                }

                @Override
                public SubBean getObject() throws Exception {
                    final A bean = this.beanFactory.getBean(A.class);
                    return new SubBean(bean);
                }
            }
            public void test() {
                applicationContext = new AnnotationConfigApplicationContext("com.xiaoxizi.spring");
                Object subBean = applicationContext.getBean("factoryBeanDemo");
                System.out.println(subBean);
            }
            肯定是会直接报错的：
            当然我们还是可以使用@Lazy解决这个问题：
            @Component
            public class A {
                public A(@Lazy final SubBean subBean) {
                    this.subBean = subBean;
                }
                private SubBean subBean;
            }

            这种情况下，spring是能正常运行的，因为我们使用@Lazy切断了循环依赖链。
            那么接下来我要说的是，正真完全无法解决的循环依赖问题：
            @AllArgsConstructor
            public class SubBeanA {
                private SubBeanB b;
            }

            @AllArgsConstructor
            public class SubBeanB {
                private SubBeanA a;
            }

            @Service
            public class FactoryBeanA implements FactoryBean<SubBeanA>, BeanFactoryAware {
                private BeanFactory beanFactory;

                @Override
                public void setBeanFactory(final BeanFactory beanFactory) throws BeansException {
                    this.beanFactory = beanFactory;
                }

                @Override
                public SubBeanA getObject() throws Exception {
                    final SubBeanB bean = (SubBeanB)this.beanFactory.getBean("factoryBeanB");
                    return new SubBeanA(bean);
                }
            }

            @Service
            public class FactoryBeanB implements FactoryBean<SubBeanB>, BeanFactoryAware {
                private BeanFactory beanFactory;

                @Override
                public void setBeanFactory(final BeanFactory beanFactory) throws BeansException {
                    this.beanFactory = beanFactory;
                }

                @Override
                public SubBeanB getObject() throws Exception {
                    final SubBeanA bean = (SubBeanA)this.beanFactory.getBean("factoryBeanA");
                    return new SubBeanB(bean);
                }
            }
            这种情况下启动会直接栈溢出的，连BeanCurrentlyInCreationException异常都不会有。
            主要原因是spring是在调用完factoryBean#getObject之后再使用singletonsCurrentlyInCreation容器进行循环依赖检测的，
            而这种循环依赖，其实是在疯狂的调用factoryBeanA#getObject -> factoryBeanB#getObject -> factoryBeanA#getObject -> ... 了，直接导致了栈溢出。

            protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {
                if (factory.isSingleton() && containsSingleton(beanName)) {
                    synchronized (getSingletonMutex()) {
                        // 在这个地方就栈溢出了
                        Object object = this.factoryBeanObjectCache.get(beanName);
                        if (object == null) {
                            Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
                            if (alreadyThere != null) {
                                object = alreadyThere;
                            }
                            else {
                                // 正常要走这里
                                if (shouldPostProcess) {
                                    // 在这里才做循环依赖检测
                                    if (isSingletonCurrentlyInCreation(beanName)) {
                                        return object;
                                    }
                                    // 在这里才做循环依赖检测
                                    beforeSingletonCreation(beanName);
                                    try {
                                        object = postProcessObjectFromFactoryBean(object, beanName);
                                    }
                                    catch (Throwable ex) {
                                        throw new BeanCreationException(...);
                                    }
                                    finally {
                                        afterSingletonCreation(beanName);
                                    }
                                }
                                if (containsSingleton(beanName)) {
                                    this.factoryBeanObjectCache.put(beanName, object);
                                }
                            }
                        }
                        return object;
                    }
                }
                // 跳过
            }

        四、小结
            1.单例的factoryBean对象本身会在spring容器启动时主动初始化。而subBean的初始化则是在第一次需要获取时才会触发。
            2.如果factoryBean对象实现的接口是SmartFactoryBean且isEagerInit方法返回true，那么subBean对象也会在spring容器启动的时候主动初始化。
            3.如果bean注册的时候，beanName对应的bean实例是一个factoryBean，
            那么我们通过getBean(beanName)获取到的对象将会是subBean对象；如果要获取工厂对象factoryBean，需要使用getBean("&" + beanName).
            4.单例的subBean也会缓存在spring容器中，具体的容器是FactoryBeanRegistrySupport#factoryBeanObjectCache，一个Map<beanName, subBean实例>。
            5.spring的三级缓存设计解决了大部分循环依赖问题，而对与subBean与普通bean的循环依赖导致可能出现两个subBean对象的问题，
            spring采用多重检查的方式，丢弃掉其中一个无用的subBean，保留已被其他bean注入的那个subBean实例。
            6.两个不同的subBean的获取逻辑factoryBean#getObject中的相互循环依赖是无法解决的，
            因为这种注入对spring来讲有点类似于构造器注入，也就是说这种循环依赖是构造器循环依赖，而且无法使用@Lazy强行切断，所以一定不要写这种代码。



























































































































































懺悔録 - 黒木渚 (KUROKI NAGISA)
词：黒木渚
曲：黒木渚
失敗作だったよ
あらかじめの不平等
真上から見下ろして
掻き回してたんだよ
退屈させないよに
対立させなくちゃね
三つ巴の正義も
ぐちゃぐちゃになってく
とっておきの未来は
タチの悪いジョークさ
終らせるのが惜しくて
言いふらしたジョークさ
ごめんなさいごめんなさい
踊らせてたんだよ
空虚と熱狂がうずまきになってさ
ひざまづいて乱れきって
ぐちゃぐちゃになっちゃえ

やっぱりそうだったよ
当たり前の仲たがい
はじめから見通して
そのままにしたんだよ
悲劇のシナリオなら
派手に壊さなくちゃね
備え付けの勇気も
ボロボロになってく
とっておきの未来は
暇つぶしのジョークさ
期待させて振り落として
笑う為のジョークさ
ごめんなさいごめんなさい
遊ばせてたんだよ
平和と平凡が不細工にゆがんでさ
泣き叫んで荒れ狂って
ボロボロになっちゃえ

とっておきの未来は
暇つぶしのジョークさ
期待させて振り落として
笑う為のジョークさ
ごめんなさいごめんなさい
遊ばせてたんだよ
平和と平凡が不細工にゆがんでさ
泣き叫んで荒れ狂って
ボロボロになっちゃえ
ぐちゃぐちゃになっちゃえ



















































